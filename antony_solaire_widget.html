<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0">
  <title>Antony Solaire – Widget Photovoltaïque</title>
  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
      max-width: 900px;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    label {
      font-weight: 600;
    }
    select {
      padding: 0.25rem 0.5rem;
      font-size: 0.95rem;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    canvas {
      max-width: 100%;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <h2>Antony – historique des installations photovoltaïques</h2>

  <div class="controls">
    <div>
      <label for="metric-select">Afficher :</label>
      <select id="metric-select">
        <option value="prod_an_kwh">Production annuelle</option>
        <option value="puis_rac_kw">Puissance installée</option>
        <option value="nb_inst">Nombre d'installations</option>
      </select>
    </div>

    <div>
      <label for="mode-select">Découpage :</label>
      <select id="mode-select">
        <option value="iris">Par quartier (empilé)</option>
        <option value="total">Total Antony</option>
      </select>
    </div>
  </div>

  <div id="h-status" class="status">Chargement des données…</div>

  <canvas id="solarChart" width="800" height="400"></canvas>

  <h2>Antony – production photovoltaïque en temps quasi réel</h2>

  <div class="controls">
    <div>
      <label for="rt-mode-select">Découpage :</label>
      <select id="rt-mode-select">
        <option value="total">Total Antony</option>
        <option value="iris">Par quartier (empilé)</option>
      </select>
    </div>

    <div>
      <label>
        <input type="checkbox" id="rt-forecast-toggle" checked />
        Afficher la prévision (24 h)
      </label>
    </div>
  </div>

  <div id="rt-status" class="status">Chargement de l'irradiance…</div>
  <canvas id="realtimeChart" width="800" height="300"></canvas>

  <script>
    // -------------------------
    // Configuration / constants
    // -------------------------

    const ODRE_BASE =
      "https://odre.opendatasoft.com/api/explore/v2.1/catalog/datasets";
    const INSEE_ANTONY = "92002";

    // IRIS code name map.
    const IRIS_LABELS = {
      920020101: "Parc de Sceaux",
      920020102: "Nouveau Cimetière",
      920020103: "La Fontaine",
      920020104: "U.S. Métro",
      920020105: "Croix de Berny",
      920020106: "Velpeau",
      920020107: "Jean Moulin",
      920020201: "11 Novembre",
      920020202: "Guillebaud",
      920020203: "Chemin de Fer",
      920020204: "Bois de l'Aurore",
      920020205: "Zone d'Activités",
      920020301: "Pajeaud",
      920020302: "Parvis du Breuil et de la Bièvre",
      920020303: "Fontaine Michalon",
      920020304: "Conservatoire Darius Milhaud",
      920020305: "Grand l",
      920020306: "Lionel Terray",
      920020307: "Fontaine Mouton",
      920020308: "Baconnets",
      920020401: "Parc Heller",
      920020402: "Céline",
      920020403: "Hôtel de Ville",
      920020404: "Clinique du Bois de Verrières",
      920020405: "Ancien Cimetière",
      920020406: "Bas Graviers",
      920020407: "Les Godets",
    };

    // Metrics definitions for the historical toggle
    const METRICS = {
      nb_inst: {
        label: "Nombre d'installations",
        unit: "",
      },
      puis_rac_kw: {
        label: "Puissance photovoltaïque raccordée au réseau",
        unit: "kW",
      },
      prod_an_kwh: {
        label: "Production annuelle vers le réseau",
        unit: "kWh",
      },
    };

    // Irradiance config for the real-time graph

    const OPEN_METEO_BASE = "https://satellite-api.open-meteo.com/v1/archive";

    // NOTE: Could use per-IRIS latitude and longitude, but probably it
    // wouldn't change anything as the satellite resolution is ~5km and
    // Antony is about 5km across.
    const ANT_LAT = 48.75363; // Town hall.
    const ANT_LON = 2.29589;

    const PANEL_TILT_DEG = 30; // typical rooftop tilt
    const PANEL_AZIMUTH_DEG = 0; // 0 = south

    const CALIB_K = 0.52; // calibration factor, see calibrate.py

    const RT_PAST_HOURS = 24; // look back this many hours
    const RT_FORECAST_HOURS = 24; // look ahead this many hours
    const RT_REFRESH_MINUTES = 17; // how often we refresh the curve
    const RT_REFRESH_INTERVAL_MS = RT_REFRESH_MINUTES * 60 * 1000;

    // ------------
    // State
    // ------------

    let dataByYear = {}; // { 2017: [ {codeiris, nb_inst, puis_rac_kw, prod_an_kwh}, ...], ... }
    let years = []; // [2017, 2018, ...]
    let irisList = []; // distinct IRIS codes
    let histChart = null; // Chart.js instance for historical widget

    let rtIrrPastSeries = [];     // [{ time, gti_w_per_m2 }, ...]  (observed)
    let rtIrrForecastSeries = []; // [{ time, gti_w_per_m2 }, ...]  (forecast)
    let rtCapTotalKw = 0; // total installed PV capacity (kW)
    let rtCapTotalNb = 0; // total installed installations count
    let rtCapPerIris = []; // [{ codeiris, puis_ins_kw }, ...]
    let rtChart = null; // Chart.js instance for real-time widget

    // ------------
    // Utilities
    // ------------

    function registreDatasetId(year) {
      // Year -> "...-3112YY"
      const yy = String(year).slice(-2);
      return `registre-national-installation-production-stockage-electricite-agrege-3112${yy}`;
    }

    function irisDisplayName(codeiris) {
      if (codeiris === null || codeiris === undefined) {
        return "Quartier inconnu";
      }
      if (IRIS_LABELS[codeiris]) {
        return IRIS_LABELS[codeiris];
      }
      return `Secteur ${codeiris}`;
    }

    function setStatus(id, msg) {
      const el = document.getElementById(id);
      if (el) el.textContent = msg;
    }

    function setHistStatus(msg) {
      setStatus("h-status", msg);
    }

    function setRealtimeStatus(msg) {
      setStatus("rt-status", msg);
    }

    function showError(id, prefix, err) {
      console.error(err);
      setStatus(id, `${prefix} : ${err.message}`);
    }

    function showHistError(prefix, err) {
      showError("h-status", prefix, err);
    }

    function showRealtimeError(prefix, err) {
      showError("rt-status", prefix, err);
    }

    // ------------
    // Fetch helpers
    // ------------

    async function fetchJson(url) {
      // Disable caching in order to force a real network request each time,
      // otherwise we may get the same cached Open-Meteo real-time data for
      // every request, rather than the latest data.
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} for ${url}`);
      }
      return res.json();
    }

    async function datasetExists(datasetId) {
      // Cheap existence test: ask for 1 record
      const url = `${ODRE_BASE}/${datasetId}/records?limit=1`;
      const res = await fetch(url);
      if (res.status === 404) {
        return false;
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} probing dataset ${datasetId}`);
      }
      return true;
    }

    async function findAvailableYears(
      firstYear = 2017,
      probeFromYear = 2025,
      maxFutureYears = 2,
    ) {
      const currentYear = new Date().getFullYear();
      const years = [];

      for (let year = firstYear; year <= currentYear + maxFutureYears; year++) {
        if (year >= probeFromYear) {
          const datasetId = registreDatasetId(year);
          const exists = await datasetExists(datasetId);
          if (!exists) break;
        }
        years.push(year);
      }

      if (years.length === 0) {
        throw new Error("No yearly registre datasets found");
      }
      return years;
    }

    async function fetchAntonyYearData(year) {
      const datasetId = registreDatasetId(year);
      const base = `${ODRE_BASE}/${datasetId}/records`;

      // Before 2020: "energieannuelleinjectee"
      // From 2020 onwards: "energieannuelleglissanteinjectee"
      const energyField =
        year < 2020
          ? "energieannuelleinjectee"
          : "energieannuelleglissanteinjectee";

      const params = new URLSearchParams({
        where: [
          `codeinseecommune='${INSEE_ANTONY}'`,
          "codefiliere like 'SOLAI'",
          "codetechnologie like 'PHOTV'",
        ].join(" AND "),
        select: [
          "codeiris as codeiris",
          "sum(nbinstallations) as nb_inst",
          // Since the energy numbers (energie injectee), are for energy sent
          // to the grid, to be consistent we use capacity attached to the grid.
          "sum(puismaxrac) as puis_rac_kw",
          `sum(${energyField}) as prod_an_kwh`,
        ].join(", "),
        group_by: "codeiris",
        limit: "100",
      });

      const url = `${base}?${params.toString()}`;
      const json = await fetchJson(url);
      return json.results || [];
    }

    async function fetchAntonyCurrentInstalledCapacityKw() {
      // Latest aggregate dataset (no year suffix)
      const datasetId =
        "registre-national-installation-production-stockage-electricite-agrege";
      const base = `${ODRE_BASE}/${datasetId}/records`;

      const params = new URLSearchParams({
        where: [
          `codeinseecommune='${INSEE_ANTONY}'`,
          "codefiliere like 'SOLAI'",
          "codetechnologie like 'PHOTV'",
        ].join(" AND "),
        select: [
          "codeiris as codeiris",
          // As we just multiply the capacity by the irradiance to estimate the
          // power, use the installed capacity, whether it is attached to the
          // grid or not.  Consider for example, that a small residential
          // installation in the winter will typically self-consume all power
          // produced, and send nothing to the grid.  Our multiplication will
          // give a positive number: the amount produced and self-consumed.
          // So we fundamentally aren't estimating the amount sent to the grid,
          // which is why it makes no sense to use the capacity attached to the
          // grid.
          "sum(puismaxinstallee) as puis_ins_kw",
          "sum(nbinstallations) as nb_inst",
        ].join(", "),
        group_by: "codeiris",
        limit: "100",
      });

      const url = `${base}?${params.toString()}`;
      const json = await fetchJson(url);
      const rows = json.results || [];

      let totalKw = 0;
      let totalNb = 0;
      for (const row of rows) {
        const v = Number(row.puis_ins_kw) || 0;
        const n = Number(row.nb_inst) || 0;
        row.puis_ins_kw = v;
        row.nb_inst = n;
        totalKw += v;
        totalNb += n;
      }

      return {
        totalKw,
        totalNb,
        perIris: rows, // reserved for future by-quartier curves
      };
    }

    async function fetchIrradianceSeries(lat, lon, pastHours, forecastHours) {
      const params = new URLSearchParams({
        latitude: String(lat),
        longitude: String(lon),
        hourly: "global_tilted_irradiance",
        tilt: String(PANEL_TILT_DEG),
        azimuth: String(PANEL_AZIMUTH_DEG),
        timeformat: "iso8601",
        timezone: "Europe/Paris",
        time_resolution: "native",
        past_hours: String(pastHours),
        forecast_hours: String(forecastHours),
      });

      const url = `${OPEN_METEO_BASE}?${params.toString()}`;
      const json = await fetchJson(url);

      const times = json.hourly?.time || [];
      const gti = json.hourly?.global_tilted_irradiance || [];

      if (times.length !== gti.length) {
        console.warn(
          "Open-Meteo: nombre de timestamps différent du nombre de valeurs irradiance :",
          "times =", times.length,
          "gti =", gti.length,
        );
      }

      const expectedTotal = pastHours + forecastHours;
      if (times.length !== expectedTotal) {
        console.warn(
          "Open-Meteo: longueur inattendue de la série irradiance :",
          "attendu =", expectedTotal,
          "reçu =", times.length,
        );
      }

      const totalToUse = Math.min(expectedTotal, times.length, gti.length);
      const splitIndex = Math.min(pastHours, totalToUse);

      const past = [];
      const forecast = [];

      for (let i = 0; i < totalToUse; i++) {
        const tIso = times[i];
        const v = gti[i];

        const point = v == null ? null : { time: tIso, gti_w_per_m2: v };

        if (i < splitIndex) {
          if (point) past.push(point);
        } else {
          if (point) forecast.push(point);
        }
      }

      return { past, forecast };
    }

    // ------------
    // Data preparation
    // ------------

    function computeIrisList() {
      const codes = new Set();
      for (const yr of years) {
        const rows = dataByYear[yr] || [];
        for (const row of rows) {
          codes.add(row.codeiris);
        }
      }
      // Convert to array, null first, others sorted
      const arr = Array.from(codes);
      arr.sort((a, b) => {
        if (a === null) return -1;
        if (b === null) return 1;
        return a.localeCompare(b);
      });
      irisList = arr;
    }

    function getValue(row, metricKey) {
      const v = row[metricKey];
      if (v === null || v === undefined) return 0;
      // ODRE sometimes returns numbers as strings; make sure we parse
      return Number(v) || 0;
    }

    function computePowerSeriesKw(irrSeries, totalKw) {
      return irrSeries.map((pt) => {
        const frac = pt.gti_w_per_m2 / 1000.0; // 1000 W/m² ~ full power
        const pKw = CALIB_K * totalKw * frac;
        return {
          time: pt.time,
          power_kw: pKw,
        };
      });
    }

    // ------------
    // Chart building
    // ------------

    function buildHistDatasets(metricKey, mode) {
      const metricDef = METRICS[metricKey];

      // Mode 1: total Antony (one bar per year)
      if (mode === "total") {
        const values = years.map((yr) => {
          const rows = dataByYear[yr] || [];
          return rows.reduce((sum, row) => sum + getValue(row, metricKey), 0);
        });

        return {
          datasets: [
            {
              label: "Total Antony",
              data: values,
              stack: "stack1",
            },
          ],
          metricLabel: metricDef.label,
          metricUnit: metricDef.unit,
        };
      }

      // Mode 2: by IRIS (stacked)
      const datasets = [];

      irisList.forEach((code) => {
        const values = years.map((yr) => {
          const rows = dataByYear[yr] || [];
          const row = rows.find((r) => r.codeiris === code);
          if (!row) return 0;
          return getValue(row, metricKey);
        });

        datasets.push({
          label: irisDisplayName(code),
          data: values,
          stack: "stack1",
        });
      });

      return { datasets, metricLabel: metricDef.label, metricUnit: metricDef.unit };
    }

    function buildRealtimeDatasets(mode, showForecast) {
      const past = rtIrrPastSeries || [];
      const forecast = rtIrrForecastSeries || [];

      if (!past.length && !forecast.length) {
        return { labels: [], datasets: [] };
      }

      let labels = [];
      const pastTimes = past.map((p) => p.time);
      const forecastTimes = forecast.map((p) => p.time);

      if (showForecast && forecastTimes.length) {
        labels = pastTimes.concat(forecastTimes);
      } else {
        labels = pastTimes;
      }

      // --- TOTAL MODE ---
      if (mode === "total") {
        const pastSeries = computePowerSeriesKw(past, rtCapTotalKw);
        const pastData = pastSeries.map((p) => p.power_kw);

        if (!showForecast || !forecast.length) {
          return {
            labels,
            datasets: [
              {
                label: "Puissance produite totale",
                data: pastData,
                borderWidth: 2,
                tension: 0.2,
                pointRadius: 0,
                pointHitRadius: 10,
                fill: true,
                stack: "rt-total",
              },
            ],
          };
        }

        const forecastSeries = computePowerSeriesKw(
          forecast,
          rtCapTotalKw,
        );
        const forecastData = forecastSeries.map((p) => p.power_kw);

        const nPast = pastData.length;
        const nForecast = forecastData.length;

        // Blue: real data, then nulls
        const pastDataPadded = pastData.concat(
          new Array(nForecast).fill(null),
        );

        // Red: start exactly at the last past point,
        // then continue with the forecast
        let forecastDataPadded;
        if (nPast > 0) {
          const lastPast = pastData[nPast - 1];
          forecastDataPadded = new Array(nPast - 1)
            .fill(null)
            .concat([lastPast])
            .concat(forecastData);
        } else {
          // No past data at all – just show the forecast
          forecastDataPadded = forecastData.slice();
        }

        return {
          labels,
          datasets: [
            {
              label: "Puissance produite totale (observée)",
              data: pastDataPadded,
              borderWidth: 2,
              tension: 0.2,
              pointRadius: 0,
              pointHitRadius: 10,
              fill: true,
              stack: "rt-total",
              showInLegend: true,
            },
            {
              label: "Prévision (24 h)",
              data: forecastDataPadded,
              borderWidth: 2,
              borderDash: [5, 5],
              tension: 0.2,
              pointRadius: 0,
              pointHitRadius: 10,
              fill: true,
              stack: "rt-total",
              showInLegend: true,
            },
          ],
        };
      }

      // --- IRIS MODE: one stacked area per quartier ---
      const datasets = [];
      const nPast = pastTimes.length;
      const nForecast = forecastTimes.length;

      for (const row of rtCapPerIris || []) {
        const capKw = Number(row.puis_ins_kw) || 0;
        if (capKw <= 0) continue;

        const codeiris = row.codeiris === undefined ? null : row.codeiris;
        const name = irisDisplayName(codeiris);

        // Observed part
        const pastData = past.map((pt) => {
          const frac = pt.gti_w_per_m2 / 1000.0;
          return CALIB_K * capKw * frac;
        });

        if (!showForecast || !forecast.length) {
          datasets.push({
            label: name,
            data: pastData,
            borderWidth: 1,
            tension: 0.2,
            pointRadius: 0,
            pointHitRadius: 10,
            fill: true,
            stack: "rt-iris",
            showInLegend: true,
          });
          continue;
        }

        // Forecast part
        const forecastData = forecast.map((pt) => {
          const frac = pt.gti_w_per_m2 / 1000.0;
          return CALIB_K * capKw * frac;
        });

        const pastDataPadded = pastData.concat(
          new Array(nForecast).fill(null),
        );

        let forecastDataPadded;
        const nPastLocal = pastData.length;

        if (nPastLocal > 0) {
          const lastPast = pastData[nPastLocal - 1];
          forecastDataPadded = new Array(nPastLocal - 1)
            .fill(null)
            .concat([lastPast])
            .concat(forecastData);
        } else {
          forecastDataPadded = forecastData.slice();
        }

        datasets.push({
          label: `${name} (observé)`,
          data: pastDataPadded,
          borderWidth: 1,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-iris",
          showInLegend: true,
        });

        datasets.push({
          label: `${name} (prévision)`,
          data: forecastDataPadded,
          borderWidth: 1,
          borderDash: [5, 5],
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-iris",
          showInLegend: false, // hidden in legend to avoid clutter
        });
      }

      return { labels, datasets };
    }

    function createOrUpdateHistChart(metricKey) {
      const ctx = document.getElementById("solarChart").getContext("2d");
      const modeSelect = document.getElementById("mode-select");
      const mode = modeSelect ? modeSelect.value : "iris"; // default

      const { datasets, metricLabel, metricUnit } = buildHistDatasets(
        metricKey,
        mode,
      );
      const yLabel = metricUnit ? `${metricLabel} (${metricUnit})` : metricLabel;
      const stacked = mode === "iris";

      if (histChart) {
        histChart.data.labels = years;
        histChart.data.datasets = datasets;
        histChart.options.plugins.title.text = metricLabel;
        histChart.options.scales.y.title.text = yLabel;
        histChart.options.scales.x.stacked = stacked;
        histChart.options.scales.y.stacked = stacked;
        histChart.update();
        return;
      }

      histChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: years,
          datasets: datasets,
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: metricLabel,
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  const label = context.dataset.label || "";
                  const value = context.parsed.y;
                  return `${label}: ${value.toLocaleString("fr-FR")}`;
                },
              },
            },
          },
          scales: {
            x: {
              stacked: stacked,
            },
            y: {
              stacked: stacked,
              beginAtZero: true,
              title: {
                display: true,
                text: yLabel,
              },
            },
          },
        },
      });
    }

    function createOrUpdateRealtimeChart() {
      const canvas = document.getElementById("realtimeChart");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");

      const modeSelect = document.getElementById("rt-mode-select");
      const mode = modeSelect ? modeSelect.value : "total";

      const forecastToggle = document.getElementById("rt-forecast-toggle");
      const showForecast = forecastToggle ? forecastToggle.checked : false;

      const { labels, datasets } = buildRealtimeDatasets(mode, showForecast);
      const yLabel = "Puissance (kW)";
      const stacked = mode === "iris";

      if (rtChart) {
        rtChart.data.labels = labels;
        rtChart.data.datasets = datasets;
        rtChart.options.scales.x.stacked = stacked;
        rtChart.options.scales.y.stacked = stacked;
        rtChart.update();
        return;
      }

      rtChart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets,
        },
        options: {
          responsive: true,
          interaction: {
            mode: "nearest",
            intersect: false,
          },
          plugins: {
            title: {
              display: true,
              text: "Production estimée à partir des données météo",
            },
            tooltip: {
              callbacks: {
                title: function (items) {
                  const label = items[0].label;
                  return `Heure : ${label}`;
                },
                label: function (context) {
                  const v = context.parsed.y;
                  return `Puissance estimée : ${v.toFixed(1)} kW`;
                },
              },
            },
            legend: {
              labels: {
                // Only show datasets that explicitly want to appear
                filter: function (item, data) {
                  const datasets = (data && data.datasets) || [];
                  const ds = datasets[item.datasetIndex];

                  if (!ds) return true;
                  if (ds.showInLegend === false) return false;
                  return true;
                },
              },
            },
          },
          scales: {
            x: {
              type: "category",
              stacked: stacked,
              ticks: {
                callback: function (value, index) {
                  const allLabels = this.chart.data.labels || [];
                  const label = allLabels[index] || "";
                  if (!label) return "";
                  const t = label.split("T")[1] || label;
                  return t.slice(0, 5); // "HH:MM"
                },
              },
            },
            y: {
              beginAtZero: true,
              stacked: stacked,
              title: {
                display: true,
                text: yLabel,
              },
            },
          },
        },
      });
    }

    async function fetchIrradianceAndUpdate() {
      const { past, forecast } = await fetchIrradianceSeries(
        ANT_LAT,
        ANT_LON,
        RT_PAST_HOURS,
        RT_FORECAST_HOURS
      );

      rtIrrPastSeries = past;
      rtIrrForecastSeries = forecast;

      createOrUpdateRealtimeChart();
    }

    // ------------
    // Main init
    // ------------

    async function initHist() {
      try {
        setHistStatus("Recherche des années disponibles…");
        years = await findAvailableYears();
        setHistStatus(
          `Années disponibles : ${years.join(", ")}. Chargement des données d'Antony…`,
        );

        // Fetch Antony data for each year
        for (const year of years) {
          const rows = await fetchAntonyYearData(year);
          dataByYear[year] = rows;
        }

        computeIrisList();
        setHistStatus(
          "Données chargées. Vous pouvez changer la métrique avec le menu déroulant.",
        );

        const metricSelect = document.getElementById("metric-select");
        const modeSelect = document.getElementById("mode-select");

        const initialMetric = metricSelect.value;
        createOrUpdateHistChart(initialMetric);

        metricSelect.addEventListener("change", () => {
          createOrUpdateHistChart(metricSelect.value);
        });

        modeSelect.addEventListener("change", () => {
          createOrUpdateHistChart(metricSelect.value);
        });
      } catch (err) {
        showHistError("Erreur lors du chargement des données", err);
      }
    }

    async function initRealtime() {
      try {
        setRealtimeStatus("Chargement de la capacité PV et de l'irradiance…");

        const cap = await fetchAntonyCurrentInstalledCapacityKw();
        if (cap.totalKw <= 0) {
          setRealtimeStatus(
            "Puissance PV totale nulle ou indisponible pour Antony.",
          );
          return;
        }

        // Save capacity info for realtime chart (total + par quartier)
        rtCapTotalKw = cap.totalKw;
        rtCapTotalNb = cap.totalNb;
        rtCapPerIris = cap.perIris || [];

        await fetchIrradianceAndUpdate();

        // The irradiance data is updated once per hour.  We poll more often
        // than that (every RT_REFRESH_MINUTES minutes) to ensure we notice
        // the new data swiftly, but the graph will only update once per hour.
        setRealtimeStatus(
          `Capacité photovoltaïque installée : ${rtCapTotalKw.toFixed(1)} kW crête (${rtCapTotalNb} installations). ` +
            `Courbe mise à jour une fois par heure.`,
        );

        // React to realtime mode toggle (total vs IRIS)
        const rtModeSelect = document.getElementById("rt-mode-select");
        if (rtModeSelect) {
          rtModeSelect.addEventListener("change", () => {
            createOrUpdateRealtimeChart();
          });
        }

        // React to forecast toggle
        const rtForecastToggle = document.getElementById("rt-forecast-toggle");
        if (rtForecastToggle) {
          rtForecastToggle.addEventListener("change", () => {
            createOrUpdateRealtimeChart();
          });
        }

        setInterval(async () => {
          try {
            await fetchIrradianceAndUpdate();
          } catch (e) {
            showRealtimeError("Erreur lors de la mise à jour", e);
          }
        }, RT_REFRESH_INTERVAL_MS);
      } catch (err) {
        showRealtimeError("Erreur lors du chargement des données temps réel", err);
      }
    }

    // Run both widgets on page load
    window.addEventListener("DOMContentLoaded", () => {
      initHist(); // historical ODRE widget (bars)
      initRealtime(); // irradiance-based real-time widget (line)
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Antony Solaire – Widget Photovoltaïque</title>
  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
      max-width: 900px;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    label {
      font-weight: 600;
    }
    select {
      padding: 0.25rem 0.5rem;
      font-size: 0.95rem;
    }
    #h-status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    #rt-status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    canvas {
      max-width: 100%;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <h1>Antony – historique des installations photovoltaïques</h1>

  <div class="controls">
    <div>
      <label for="metric-select">Afficher :</label>
      <select id="metric-select">
        <option value="prod_an_kwh">Production annuelle</option>
        <option value="puis_rac_kw">Puissance installée</option>
        <option value="nb_inst">Nombre d'installations</option>
      </select>
    </div>

    <div>
      <label for="mode-select">Découpage :</label>
      <select id="mode-select">
        <option value="iris">Par quartier (empilé)</option>
        <option value="total">Total Antony</option>
      </select>
    </div>
  </div>

  <div id="h-status">Chargement des données…</div>

  <canvas id="solarChart" width="800" height="400"></canvas>

  <h2>Antony – production photovoltaïque en temps quasi réel</h2>

  <div class="controls">
    <div>
      <label for="rt-mode-select">Découpage :</label>
      <select id="rt-mode-select">
        <option value="total">Total Antony</option>
        <option value="iris">Par quartier (empilé)</option>
      </select>
    </div>
  </div>

  <div id="rt-status">Chargement de l'irradiance…</div>
  <canvas id="realtimeChart" width="800" height="300"></canvas>

  <script>
    // -------------------------
    // Configuration / constants
    // -------------------------

    const ODRE_BASE = "https://odre.opendatasoft.com/api/explore/v2.1/catalog/datasets";
    const INSEE_ANTONY = "92002";

    // IRIS code name map.
    const IRIS_LABELS = {
      "920020101": "Parc de Sceaux",
      "920020102": "Nouveau Cimetière",
      "920020103": "La Fontaine",
      "920020104": "U.S. Métro",
      "920020105": "Croix de Berny",
      "920020106": "Velpeau",
      "920020107": "Jean Moulin",
      "920020201": "11 Novembre",
      "920020202": "Guillebaud",
      "920020203": "Chemin de Fer",
      "920020204": "Bois de l'Aurore",
      "920020205": "Zone d'Activités",
      "920020301": "Pajeaud",
      "920020302": "Parvis du Breuil et de la Bièvre",
      "920020303": "Fontaine Michalon",
      "920020304": "Conservatoire Darius Milhaud",
      "920020305": "Grand l",
      "920020306": "Lionel Terray",
      "920020307": "Fontaine Mouton",
      "920020308": "Baconnets",
      "920020401": "Parc Heller",
      "920020402": "Céline",
      "920020403": "Hôtel de Ville",
      "920020404": "Clinique du Bois de Verrières",
      "920020405": "Ancien Cimetière",
      "920020406": "Bas Graviers",
      "920020407": "Les Godets",
    };

    // Metrics definitions for the historical toggle
    const METRICS = {
      nb_inst: {
        label: "Nombre d'installations",
        unit: "",
      },
      puis_rac_kw: {
        label: "Puissance photovoltaïque raccordée au réseau",
        unit: "kW",
      },
      prod_an_kwh: {
        label: "Production annuelle vers le réseau",
        unit: "kWh",
      },
    };

    // Irradiance config for the real-time graph

    const OPEN_METEO_BASE = "https://satellite-api.open-meteo.com/v1/archive";

    // NOTE: Could use per-IRIS latitude and longitude, but probably it
    // wouldn't change anything as the satellite resolution is ~5km and
    // Antony is about 5km across.
    const ANT_LAT = 48.75363; const ANT_LON = 2.29589; // Town hall.

    const PANEL_TILT_DEG = 30;   // typical rooftop tilt
    const PANEL_AZIMUTH_DEG = 0; // 0 = south

    const CALIB_K = 1.0;         // calibration factor (≈1 for now)

    const RT_PAST_HOURS = 24;           // look back this many hours
    const RT_REFRESH_MINUTES = 17;      // how often we refresh the curve

    // ------------
    // State
    // ------------

    let dataByYear = {};     // { 2017: [ {codeiris, nb_inst, puis_rac_kw, prod_an_kwh}, ...], ... }
    let years = [];          // [2017, 2018, ...]
    let irisList = [];       // distinct IRIS codes
    let hchart = null;       // Chart.js instance for historical widget

    let rtIrrSeries = [];    // [{ time, gti_w_per_m2 }, ...]
    let rtCapTotalKw = 0;    // total installed PV capacity (kW)
    let rtCapPerIris = [];   // [{ codeiris, puis_ins_kw }, ...]
    let rtChart = null;      // Chart.js instance for real-time widget

    // ------------
    // Utilities
    // ------------

    function registreDatasetId(year) {
      // Year -> "...-3112YY"
      const yy = String(year).slice(-2);
      return `registre-national-installation-production-stockage-electricite-agrege-3112${yy}`;
    }

    function irisDisplayName(codeiris) {
      if (codeiris === null || codeiris === undefined) {
        return "Quartier inconnu";
      }
      if (IRIS_LABELS[codeiris]) {
        return IRIS_LABELS[codeiris];
      }
      return `Secteur ${codeiris}`;
    }

    function setStatus(msg) {
      const el = document.getElementById("h-status");
      if (el) el.textContent = msg;
    }

    function setRealtimeStatus(msg) {
      const el = document.getElementById("rt-status");
      if (el) el.textContent = msg;
    }

    // ------------
    // Fetch helpers
    // ------------

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} for ${url}`);
      }
      return res.json();
    }

    async function datasetExists(datasetId) {
      // Cheap existence test: ask for 1 record
      const url = `${ODRE_BASE}/${datasetId}/records?limit=1`;
      const res = await fetch(url);
      if (res.status === 404) {
        return false;
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} probing dataset ${datasetId}`);
      }
      return true;
    }

    async function findAvailableYears(firstYear = 2017, firstYearToTest = 2025, maxFutureYears = 2) {
      const currentYear = new Date().getFullYear();
      const years = [];

      for (let year = firstYear; year <= currentYear + maxFutureYears; year++) {
        if (year >= firstYearToTest) {
          const datasetId = registreDatasetId(year);
          const exists = await datasetExists(datasetId);
          if (!exists) break;
        }
        years.push(year);
      }

      if (years.length === 0) {
        throw new Error("No yearly registre datasets found");
      }
      return years;
    }

    async function fetchAntonyYearData(year) {
      const datasetId = registreDatasetId(year);
      const base = `${ODRE_BASE}/${datasetId}/records`;

      // Before 2020: "energieannuelleinjectee"
      // From 2020 onwards: "energieannuelleglissanteinjectee"
      const energyField =
        year < 2020
          ? "energieannuelleinjectee"
          : "energieannuelleglissanteinjectee";

      const params = new URLSearchParams({
        where: `codeinseecommune='${INSEE_ANTONY}' AND codefiliere like 'SOLAI' AND codetechnologie like 'PHOTV'`,
        select: [
          "codeiris as codeiris",
          "sum(nbinstallations) as nb_inst",
          // Since the energy numbers (energie injectee), are for energy sent
          // to the grid, to be consistent we use capacity attached to the grid.
          "sum(puismaxrac) as puis_rac_kw",
          `sum(${energyField}) as prod_an_kwh`,
        ].join(", "),
        group_by: "codeiris",
        limit: "100",
      });

      const url = `${base}?${params.toString()}`;
      const json = await fetchJson(url);
      return json.results || [];
    }

    async function fetchAntonyCurrentInstalledCapacityKw() {
      // Latest aggregate dataset (no year suffix)
      const datasetId = "registre-national-installation-production-stockage-electricite-agrege";
      const base = `${ODRE_BASE}/${datasetId}/records`;

      const params = new URLSearchParams({
        where: `codeinseecommune='${INSEE_ANTONY}' AND codefiliere like 'SOLAI' AND codetechnologie like 'PHOTV'`,
        select: [
          "codeiris as codeiris",
          // As we just multiply the capacity by the irradiance to estimate the
          // power, use the installed capacity, whether it is attached to the
          // grid or not.  Consider for example, that a small residential
          // installation in the winter will typically self-consume all power
          // produced, and send nothing to the grid.  Our multiplication will
          // give a positive number: the amount produced and self-consumed.
          // So we fundamentally aren't estimating the amount sent to the grid,
          // which is why it makes no sense to use the capacity attached to the
          // grid.
          "sum(puismaxinstallee) as puis_ins_kw"
        ].join(", "),
        group_by: "codeiris",
        limit: "100",
      });

      const url = `${base}?${params.toString()}`;
      const json = await fetchJson(url);
      const rows = json.results || [];

      let totalKw = 0;
      for (const row of rows) {
        const v = Number(row.puis_ins_kw) || 0;
        row.puis_ins_kw = v;
        totalKw += v;
      }

      return {
        totalKw,
        perIris: rows,  // reserved for future by-quartier curves
      };
    }

    async function fetchIrradianceSeries(lat, lon, pastHours) {
      const params = new URLSearchParams({
        latitude: String(lat),
        longitude: String(lon),
        hourly: "global_tilted_irradiance",
        tilt: String(PANEL_TILT_DEG),
        azimuth: String(PANEL_AZIMUTH_DEG),
        timeformat: "iso8601",
        timezone: "Europe/Paris",
        time_resolution: "native",
        past_hours: String(pastHours),
        forecast_hours: "0"
      });

      const url = `${OPEN_METEO_BASE}?${params.toString()}`;
      const json = await fetchJson(url);

      const times = json.hourly.time;
      const gti = json.hourly.global_tilted_irradiance;

      const out = [];
      for (let i = 0; i < times.length; i++) {
        const v = gti[i];
        if (v != null) {
          out.push({
            time: times[i],
            gti_w_per_m2: v,
          });
        }
      }
      return out;
    }

    // ------------
    // Data preparation
    // ------------

    function computeIrisList() {
      const codes = new Set();
      for (const yr of years) {
        const rows = dataByYear[yr] || [];
        for (const row of rows) {
          // row.codeiris may be null
          const code = row.codeiris === null ? "NULL" : row.codeiris;
          codes.add(code);
        }
      }
      // Convert to array, but keep "NULL" (Quartier Inconnu) first, others sorted
      const arr = Array.from(codes);
      arr.sort((a, b) => {
        if (a === "NULL") return -1;
        if (b === "NULL") return 1;
        return a.localeCompare(b);
      });
      irisList = arr;
    }

    function getValue(row, metricKey) {
      const v = row[metricKey];
      if (v === null || v === undefined) return 0;
      // ODRE sometimes returns numbers as strings; make sure we parse
      return Number(v) || 0;
    }

    function computePowerSeriesKw(irrSeries, totalKw) {
      return irrSeries.map(pt => {
        const frac = pt.gti_w_per_m2 / 1000.0; // 1000 W/m² ~ full power
        const pKw = CALIB_K * totalKw * frac;
        return {
          time: pt.time,
          power_kw: pKw,
        };
      });
    }

    // ------------
    // Chart building
    // ------------

    function buildHistDatasets(metricKey, mode) {
      const metricDef = METRICS[metricKey];

      // Mode 1: total Antony (one bar per year)
      if (mode === "total") {
        const values = years.map((yr) => {
          const rows = dataByYear[yr] || [];
          return rows.reduce((sum, row) => sum + getValue(row, metricKey), 0);
        });

        return {
          datasets: [{
            label: "Total Antony",
            data: values,
            stack: "stack1",
            backgroundColor: undefined,
          }],
          metricLabel: metricDef.label,
          metricUnit: metricDef.unit,
        };
      }

      // Mode 2: by IRIS (stacked)
      const datasets = [];

      irisList.forEach((code) => {
        const isNull = (code === "NULL");
        const rawCode = isNull ? null : code;

        const values = years.map((yr) => {
          const rows = dataByYear[yr] || [];
          const row = rows.find(r => (r.codeiris === rawCode));
          if (!row) return 0;
          return getValue(row, metricKey);
        });

        datasets.push({
          label: irisDisplayName(rawCode),
          data: values,
          stack: "stack1",
          backgroundColor: undefined,
        });
      });

      return { datasets, metricLabel: metricDef.label, metricUnit: metricDef.unit };
    }

    function buildRealtimeDatasets(mode) {
      // Common x-axis labels: timestamps from irradiance series
      const labels = rtIrrSeries.map(p => p.time);

      // Safety: if we don't have data yet, return empty
      if (!labels.length) {
        return { labels: [], datasets: [] };
      }

      // Mode "total": one line for Antony as a whole
      if (mode === "total") {
        const totalSeries = computePowerSeriesKw(rtIrrSeries, rtCapTotalKw);
        const data = totalSeries.map(p => p.power_kw);

        return {
          labels,
          datasets: [
            {
              label: "Puissance estimée totale",
              data,
              borderWidth: 2,
              tension: 0.2,
              pointRadius: 0,
              pointHitRadius: 10,
              fill: true,
              stack: "rt-total",
            },
          ],
        };
      }

      // Mode "iris": one stacked area per quartier
      const datasets = [];

      for (const row of rtCapPerIris || []) {
        const capKw = Number(row.puis_ins_kw) || 0;
        if (capKw <= 0) continue;

        const codeiris = row.codeiris === undefined ? null : row.codeiris;
        const name = irisDisplayName(codeiris);

        const data = rtIrrSeries.map(pt => {
          const frac = pt.gti_w_per_m2 / 1000.0; // 1000 W/m² ≈ full power
          return CALIB_K * capKw * frac;
        });

        datasets.push({
          label: name,
          data,
          borderWidth: 1,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-iris",
        });
      }

      return { labels, datasets };
    }

    function createOrUpdateHistChart(metricKey) {
      const ctx = document.getElementById("solarChart").getContext("2d");
      const modeSelect = document.getElementById("mode-select");
      const mode = modeSelect ? modeSelect.value : "iris";  // default

      const { datasets, metricLabel, metricUnit } = buildHistDatasets(metricKey, mode);
      const yLabel = metricUnit ? `${metricLabel} (${metricUnit})` : metricLabel;
      const stacked = (mode === "iris");

      if (hchart) {
        hchart.data.labels = years;
        hchart.data.datasets = datasets;
        hchart.options.plugins.title.text = metricLabel;
        hchart.options.scales.y.title.text = yLabel;
        hchart.options.scales.x.stacked = stacked;
        hchart.options.scales.y.stacked = stacked;
        hchart.update();
        return;
      }

      hchart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: years,
          datasets: datasets,
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: metricLabel,
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  const label = context.dataset.label || "";
                  const value = context.parsed.y;
                  return `${label}: ${value.toLocaleString("fr-FR")}`;
                },
              },
            },
          },
          scales: {
            x: {
              stacked: stacked,
            },
            y: {
              stacked: stacked,
              beginAtZero: true,
              title: {
                display: true,
                text: yLabel,
              },
            },
          },
        },
      });
    }

    function createOrUpdateRealtimeChart() {
      const canvas = document.getElementById("realtimeChart");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");

      const modeSelect = document.getElementById("rt-mode-select");
      const mode = modeSelect ? modeSelect.value : "total";

      const { labels, datasets } = buildRealtimeDatasets(mode);
      const yLabel = "Puissance photovoltaïque (kW)";
      const stacked = (mode === "iris");

      if (rtChart) {
        rtChart.data.labels = labels;
        rtChart.data.datasets = datasets;
        rtChart.options.scales.y.stacked = stacked;
        rtChart.update();
        return;
      }

      rtChart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets,
        },
        options: {
          responsive: true,
          interaction: {
            mode: "nearest",
            intersect: false,
          },
          plugins: {
            title: {
              display: true,
              text: "Production estimée à partir des données météo",
            },
            tooltip: {
              callbacks: {
                title: function (items) {
                  const label = items[0].label;
                  return `Heure : ${label}`;
                },
                label: function (context) {
                  const v = context.parsed.y;
                  return `Puissance estimée : ${v.toFixed(1)} kW`;
                },
              },
            },
          },
          scales: {
            x: {
              type: "category",
              ticks: {
                callback: function (value, index, ticks) {
                  const label = labels[index];
                  const t = label.split("T")[1] || label;
                  return t.slice(0, 5); // "HH:MM"
                },
              },
            },
            y: {
              beginAtZero: true,
              stacked: stacked,
              title: {
                display: true,
                text: yLabel,
              },
            },
          },
        },
      });
    }

    // ------------
    // Main init
    // ------------

    async function initHist() {
      try {
        setStatus("Recherche des années disponibles…");
        years = await findAvailableYears();
        setStatus(`Années disponibles : ${years.join(", ")}. Chargement des données d'Antony…`);

        // Fetch Antony data for each year
        for (const year of years) {
          const rows = await fetchAntonyYearData(year);
          dataByYear[year] = rows;
        }

        computeIrisList();
        setStatus("Données chargées. Vous pouvez changer la métrique avec le menu déroulant.");

        const metricSelect = document.getElementById("metric-select");
        const modeSelect = document.getElementById("mode-select");

        const initialMetric = metricSelect.value;
        createOrUpdateHistChart(initialMetric);

        metricSelect.addEventListener("change", () => {
          createOrUpdateHistChart(metricSelect.value);
        });

        modeSelect.addEventListener("change", () => {
          createOrUpdateHistChart(metricSelect.value);
        });

      } catch (err) {
        console.error(err);
        setStatus("Erreur lors du chargement des données : " + err.message);
      }
    }

    async function initRealtime() {
      try {
        setRealtimeStatus("Chargement de la capacité PV et de l'irradiance…");

        const cap = await fetchAntonyCurrentInstalledCapacityKw();
        if (cap.totalKw <= 0) {
          setRealtimeStatus("Puissance PV totale nulle ou indisponible pour Antony.");
          return;
        }

        // Save capacity info for realtime chart (total + par quartier)
        rtCapTotalKw = cap.totalKw;
        rtCapPerIris = cap.perIris || [];

        const irr = await fetchIrradianceSeries(ANT_LAT, ANT_LON, RT_PAST_HOURS);
        rtIrrSeries = irr;

        createOrUpdateRealtimeChart();
        setRealtimeStatus(
          `Puissance photovoltaïque totale : ${rtCapTotalKw.toFixed(1)} kW. ` +
          `Courbe mise à jour une fois par heure.`
        );

        // React to realtime mode toggle (total vs IRIS)
        const rtModeSelect = document.getElementById("rt-mode-select");
        if (rtModeSelect) {
          rtModeSelect.addEventListener("change", () => {
            createOrUpdateRealtimeChart();
          });
        }

        // Periodic refresh
        setInterval(async () => {
          try {
            const irrNew = await fetchIrradianceSeries(ANT_LAT, ANT_LON, RT_PAST_HOURS);
            rtIrrSeries = irrNew;
            createOrUpdateRealtimeChart();
          } catch (e) {
            console.error(e);
            setRealtimeStatus("Erreur lors de la mise à jour temps réel : " + e.message);
          }
        }, RT_REFRESH_MINUTES * 60 * 1000);

      } catch (err) {
        console.error(err);
        setRealtimeStatus("Erreur lors du chargement des données temps réel : " + err.message);
      }
    }

    // Run both widgets on page load
    window.addEventListener("DOMContentLoaded", () => {
      initHist();     // historical ODRE widget (bars)
      initRealtime(); // irradiance-based real-time widget (line)
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0">
  <title>Antony Solaire – Widget Photovoltaïque</title>
  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
      max-width: 900px;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    label {
      font-weight: 600;
    }
    select {
      padding: 0.25rem 0.5rem;
      font-size: 0.95rem;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    canvas {
      max-width: 100%;
      margin-top: 1rem;
    }
    button {
      padding: 0.28rem 0.6rem;
      font-size: 0.95rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      background: #fafafa;
      cursor: pointer;
    }
    button:hover { background: #f2f2f2; }
    .rt-array-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.6rem;
      padding: 0.45rem 0.6rem;
      border: 1px solid #e6e6e6;
      border-radius: 0.75rem;
      background: #fff;
    }
    .rt-array-row input[type="number"] {
      width: 4rem;
      margin-left: 0.25rem;
    }
    .rt-array-name { width: 9rem; }
  </style>
</head>
<body>
  <h2>Antony – historique des installations photovoltaïques</h2>

  <div class="controls">
    <div>
      <label for="h-metric-select">Afficher :</label>
      <select id="h-metric-select">
        <option value="prod_an_kwh">Production annuelle</option>
        <option value="puis_rac_kw">Puissance installée</option>
        <option value="nb_inst">Nombre d'installations</option>
        <option value="conso_totale_kwh">Consommation annuelle</option>
      </select>
    </div>

    <div>
      <label for="h-mode-select">Découpage :</label>
      <select id="h-mode-select">
        <option value="iris">Par quartier</option>
        <option value="total">Total Antony</option>
      </select>
    </div>
  </div>

  <div id="h-status" class="status">Chargement des données…</div>

  <canvas id="historyChart" width="800" height="400"></canvas>

  <h2>Antony – production photovoltaïque en temps quasi réel</h2>

  <div class="controls">
    <div>
      <label for="rt-mode-select">Affichage :</label>
      <select id="rt-mode-select">
        <option value="total">Total Antony</option>
        <option value="iris">Par quartier</option>
        <option value="personal">Mon installation</option>
      </select>
    </div>

    <div>
      <label>
        <input type="checkbox" id="rt-forecast-toggle" checked />
        Afficher la prévision (24 h)
      </label>
    </div>

    <div id="rt-personal-controls" style="display:none; gap: 0.75rem; flex-wrap: wrap;">
      <span style="font-weight:600;">Paramètres personnels :</span>

      <div style="display:flex; flex-direction:column; gap:0.6rem; width:100%;">
        <div id="rt-arrays" style="display:flex; flex-direction:column; gap:0.6rem; width:100%;"></div>
        <div style="display:flex; align-items:center; gap:0.75rem; flex-wrap:wrap;">
          <button type="button" id="rt-add-array">+ Ajouter un champ</button>
          <span style="font-size:0.9rem; color:#555;">
            Astuce : mettez par ex. 2 champs (Est / Ouest) pour visualiser l'empilement.
          </span>
        </div>
      </div>
    </div>
  </div>

  <div id="rt-status" class="status">Chargement de l'irradiance…</div>
  <canvas id="realtimeChart" width="800" height="300"></canvas>

<script>
(() => {
  // -------------------------
  // Configuration / constants
  // -------------------------

  const NAME_COMMUNE = "Antony"
  const INSEE_COMMUNE = "92002"; // Antony

  // Satellite resolution is ~5km and Antony is about 5km across, so use a
  // single reference location somewhere in the middle for all of Antony.
  const ANT_LAT = 48.75363; // The town hall is in the middle of Antony.
  const ANT_LON = 2.29589;

  const IRIS_LABELS = { // Antony IRIS names.  See iris-list.py
    920020101: "Parc de Sceaux",
    920020102: "Nouveau Cimetière",
    920020103: "La Fontaine",
    920020104: "U.S. Métro",
    920020105: "Croix de Berny",
    920020106: "Velpeau",
    920020107: "Jean Moulin",
    920020201: "11 Novembre",
    920020202: "Guillebaud",
    920020203: "Chemin de Fer",
    920020204: "Bois de l'Aurore",
    920020205: "Zone d'Activités",
    920020301: "Pajeaud",
    920020302: "Parvis du Breuil et de la Bièvre",
    920020303: "Fontaine Michalon",
    920020304: "Conservatoire Darius Milhaud",
    920020305: "Grand l",
    920020306: "Lionel Terray",
    920020307: "Fontaine Mouton",
    920020308: "Baconnets",
    920020401: "Parc Heller",
    920020402: "Céline",
    920020403: "Hôtel de Ville",
    920020404: "Clinique du Bois de Verrières",
    920020405: "Ancien Cimetière",
    920020406: "Bas Graviers",
    920020407: "Les Godets",
  };


  const PANEL_TILT_DEG = 30;     // typical rooftop tilt
  const PANEL_AZIMUTH_DEG = 0;   // 0 = south
  const CALIB_K = 0.52;          // calibration factor, see calibrate.py


  const NOCT = 45;       // Nominal operating cell temperature, °C
  const GAMMA = -0.004;  // Power drop as cell temperature rises: -0.4 %/°C


  const CONCURRENCY = 4; // 4–6 is usually polite


  const RT_PAST_HOURS = 24;
  const RT_FORECAST_HOURS = 24;
  const RT_REFRESH_MINUTES = 17; // Notice new data fairly quickly, while staying polite
  const RT_REFRESH_INTERVAL_MS = RT_REFRESH_MINUTES * 60 * 1000;


  const ODRE_BASE = "https://odre.opendatasoft.com/api/explore/v2.1/catalog/datasets";
  const AGENCE_ORE_BASE = "https://opendata.agenceore.fr/api/explore/v2.1/catalog/datasets";
  const OPEN_METEO_BASE = "https://satellite-api.open-meteo.com/v1/archive";


  const HIST_METRICS = {
    nb_inst: { label: "Nombre d'installations", unit: "", source: "pv" },
    puis_rac_kw: { label: "Puissance photovoltaïque raccordée au réseau", unit: "kW", source: "pv" },
    prod_an_kwh: { label: "Production annuelle vers le réseau", unit: "kWh", source: "pv" },
    conso_totale_kwh: { label: "Consommation annuelle", unit: "kWh", source: "conso" },
  };

  const RT_METRICS = {
    power_kw: {
      label: "Puissance estimée",
      unit: "kW",
      axisLabel: "Puissance (kW)",
      tooltip: (v) => `Puissance estimée : ${v.toFixed(1)} kW`,
    },

    // In case we ever want to chart irradiance directly
    gti_wm2: {
      label: "Irradiance (plan incliné)",
      unit: "W/m²",
      axisLabel: "Irradiance (W/m²)",
      tooltip: (v) => `Irradiance : ${v.toFixed(0)} W/m²`,
    },
  };

  // ------------
  // DOM cache
  // ------------

  const dom = {};
  const $ = (id) => document.getElementById(id);

  function cacheDom() {
    dom.hMetricSelect = $("h-metric-select");
    dom.hModeSelect = $("h-mode-select");
    dom.hStatus = $("h-status");
    dom.histCanvas = $("historyChart");

    dom.rtStatus = $("rt-status");
    dom.rtCanvas = $("realtimeChart");
    dom.rtModeSelect = $("rt-mode-select");
    dom.rtForecastToggle = $("rt-forecast-toggle");
    dom.rtPersonalControls = $("rt-personal-controls");

    dom.rtArraysContainer = $("rt-arrays");
    dom.rtAddArrayBtn = $("rt-add-array");
  }

  // ------------
  // State
  // ------------

  const hist = {
    years: [],
    pvByYear: {},
    consoByYear: {},
    consoIndexByYear: {}, // year -> Map(codeiris -> { total, byFiliere: Map(filiere -> value) })
    consoFilieres: [],    // stable list for total chart stacking
    pvIrisList: [],       // IRIS codes that have PV data (for PV charts)
    consoIrisList: [],    // IRIS codes that have consumption data (for conso charts)
    chart: null,
  };

  const rt = {
    // Commune irradiance
    irrPastCommune: [],
    irrForecastCommune: [],

    // Commune temperature
    tempPast: [],
    tempForecast: [],

    // Commune capacities
    capTotalKw: 0,
    capTotalNb: 0,
    capPerIris: [],

    // Personal configuration
    personalArrays: [
      {
        id: "arr1",
        name: "Champ 1",
        p_kwc: 3.0,
        tilt_deg: PANEL_TILT_DEG,
        azimuth_deg: PANEL_AZIMUTH_DEG,
        perf_factor: 0.85,
        irrPast: [],
        irrForecast: [],
      },
    ],

    chart: null,
  };

  const personalArrayDebouncers = new Map(); // arrayId -> debounced fn

  // ------------
  // Utilities
  // ------------

  function registreDatasetId(year) {
    const yy = String(year).slice(-2);
    return `registre-national-installation-production-stockage-electricite-agrege-3112${yy}`;
  }

  function normalizeIrisCode(raw) {
    if (raw === undefined || raw === null) return null;
    const s = String(raw).trim();
    // A true IRIS is a 9-digit code. Turn anything else (e.g., "92002XXXX") into null.
    return /^\d{9}$/.test(s) ? Number(s) : null;
  }

  function irisDisplayName(codeiris) {
    if (codeiris === null || codeiris === undefined) return "Quartier inconnu";
    if (IRIS_LABELS[codeiris]) return IRIS_LABELS[codeiris];
    return `Secteur ${codeiris}`;
  }

  function setStatus(el, msg) {
    if (el) el.textContent = msg;
  }

  function setHistStatus(msg) {
    setStatus(dom.hStatus, msg);
  }

  function setRealtimeStatus(msg) {
    setStatus(dom.rtStatus, msg);
  }

  function showError(el, prefix, err) {
    console.error(err);
    setStatus(el, `${prefix} : ${err.message}`);
  }

  function debounce(fn, delayMs) {
    let timeoutId = null;
    return function (...args) {
      if (timeoutId !== null) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(this, args), delayMs);
    };
  }

  // Debounce chart refresh so typing doesn't redraw on every keystroke.
  // Separate from the "fetch irradiance" debounce used for tilt/azimuth.
  const debouncedRealtimeChartUpdate = debounce(() => {
    if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
  }, 1000);

  function getCurrentRealtimeMode() {
    return dom.rtModeSelect ? dom.rtModeSelect.value : "total";
  }

  // ----------------------------
  // Persistence (localStorage)
  // ----------------------------

  const PERSONAL_STORAGE_KEY = `${NAME_COMMUNE}Solar.personalArrays.v1`;

  function serializePersonalArrays(arrays) {
    return {
      v: 1,
      savedAt: new Date().toISOString(),
      arrays: (arrays || []).map(a => ({
        id: String(a.id || ""),
        name: String(a.name || ""),
        p_kwc: Number(a.p_kwc) || 0,
        tilt_deg: clamp(a.tilt_deg, 0, 90),
        azimuth_deg: clamp(a.azimuth_deg, -180, 180),
        perf_factor: clamp((Number(a.perf_factor) || 0) * 100, 10, 120) / 100,
      })),
    };
  }

  function restorePersonalArrays(payload) {
    const arraysIn = payload?.arrays;
    if (!Array.isArray(arraysIn) || arraysIn.length === 0) return null;

    const restored = [];
    for (const a of arraysIn) {
      const id = (a && typeof a.id === "string" && a.id.trim())
        ? a.id.trim()
        : `arr${Date.now()}_${Math.floor(Math.random() * 1e6)}`;
      restored.push({
        id,
        name: (a && typeof a.name === "string" && a.name.trim()) ? a.name.trim() : "Champ",
        p_kwc: Math.max(0, Number(a.p_kwc) || 0),
        tilt_deg: clamp(a.tilt_deg, 0, 90),
        azimuth_deg: clamp(a.azimuth_deg, -180, 180),
        perf_factor: clamp((Number(a.perf_factor) || 0) * 100, 10, 120) / 100,
        irrPast: [],
        irrForecast: [],
      });
    }
    return restored.length ? restored : null;
  }

  function savePersonalArraysToStorage() {
    try {
      const payload = serializePersonalArrays(rt.personalArrays);
      localStorage.setItem(PERSONAL_STORAGE_KEY, JSON.stringify(payload));
    } catch (e) {
      // Ignore (private mode / blocked storage / quota). Widget still works.
    }
  }

  function loadPersonalArraysFromStorage() {
    try {
      const raw = localStorage.getItem(PERSONAL_STORAGE_KEY);
      if (!raw) return false;
      const payload = JSON.parse(raw);
      const restored = restorePersonalArrays(payload);
      if (!restored) return false;
      rt.personalArrays = restored;
      return true;
    } catch (e) {
      return false;
    }
  }

  const debouncedSavePersonalArrays = debounce(savePersonalArraysToStorage, 1000);

  // ------------
  // Fetch helpers
  // ------------

  async function fetchJson(url) {
    const res = await fetch(url)
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return res.json();
  }

  async function datasetExists(datasetId) {
    const url = `${ODRE_BASE}/${datasetId}/records?limit=1`;
    const res = await fetch(url);
    if (res.status === 404) return false;
    if (!res.ok) throw new Error(`HTTP ${res.status} probing dataset ${datasetId}`);
    return true;
  }

  async function findAvailableYears(firstYear = 2017, probeFromYear = 2025, maxFutureYears = 1) {
    const currentYear = new Date().getFullYear();
    const availableYears = [];

    for (let year = firstYear; year <= currentYear + maxFutureYears; year++) {
      if (year >= probeFromYear) {
        const datasetId = registreDatasetId(year);
        const exists = await datasetExists(datasetId);
        if (!exists) break;
      }
      availableYears.push(year);
    }

    if (availableYears.length === 0) throw new Error("No yearly registre datasets found");
    return availableYears;
  }

  async function fetchCommuneYearData(year) {
    const datasetId = registreDatasetId(year);
    const base = `${ODRE_BASE}/${datasetId}/records`;

    const energyField = year < 2020 ? "energieannuelleinjectee" : "energieannuelleglissanteinjectee";

    const params = new URLSearchParams({
      where: [
        `codeinseecommune='${INSEE_COMMUNE}'`,
        "codefiliere like 'SOLAI'",
        "codetechnologie like 'PHOTV'",
      ].join(" AND "),
      select: [
        "codeiris as codeiris",
        "sum(nbinstallations) as nb_inst",
        // Since the energy numbers (energie injectee), are for energy sent
        // to the grid, to be consistent we use capacity attached to the grid.
        "sum(puismaxrac) as puis_rac_kw",
        `sum(${energyField}) as prod_an_kwh`,
      ].join(", "),
      group_by: "codeiris",
      limit: "100",
    });

    const url = `${base}?${params.toString()}`;
    const json = await fetchJson(url);
    const rows = json.results || [];
    for (const r of rows) r.codeiris = normalizeIrisCode(r.codeiris);
    return rows;
  }

  async function fetchCommuneYearConsumptionData(year) {
    const datasetId = "consommation-annuelle-d-electricite-et-gaz-par-iris";
    const base = `${AGENCE_ORE_BASE}/${datasetId}/records`;

    const params = new URLSearchParams({
      where: [
        `code_commune='${INSEE_COMMUNE}'`,
        `annee=date'${year}'`,
      ].join(" AND "),
      select: [
        "code_iris as codeiris",
        "filiere as filiere",
        "sum(conso_totale_mwh) as conso_totale_mwh",
      ].join(", "),
      group_by: "code_iris, filiere",
      limit: "100",
    });

    const url = `${base}?${params.toString()}`;
    const json = await fetchJson(url);
    const rows = json.results || [];

    // Normalize numeric field
    for (const r of rows) {
      const mwh = Number(r.conso_totale_mwh) || 0;
      // Store everything in kWh to be comparable with PV prod_an_kwh
      r.conso_totale_kwh = mwh * 1000;

      r.codeiris = normalizeIrisCode(r.codeiris);
      if (typeof r.filiere !== "string") r.filiere = String(r.filiere || "");
    }
    return rows;
  }

  async function fetchCommuneCurrentInstalledCapacityKw() {
    const datasetId = "registre-national-installation-production-stockage-electricite-agrege";
    const base = `${ODRE_BASE}/${datasetId}/records`;

    const params = new URLSearchParams({
      where: [
        `codeinseecommune='${INSEE_COMMUNE}'`,
        "codefiliere like 'SOLAI'",
        "codetechnologie like 'PHOTV'",
      ].join(" AND "),
      select: [
        "codeiris as codeiris",
        // As we just multiply the capacity by the irradiance to estimate the
        // power, use the installed capacity, whether it is attached to the
        // grid or not.  Consider, for example, that a small residential
        // installation in the winter will typically self-consume all power
        // produced, and send nothing to the grid.  Our multiplication will
        // give a positive number: the amount produced and self-consumed.
        // So we fundamentally aren't estimating the amount sent to the grid,
        // which is why it makes no sense to use the capacity attached to the
        // grid.
        "sum(puismaxinstallee) as puis_ins_kw",
        "sum(nbinstallations) as nb_inst",
      ].join(", "),
      group_by: "codeiris",
      limit: "100",
    });

    const url = `${base}?${params.toString()}`;
    const json = await fetchJson(url);
    const rows = json.results || [];

    let totalKw = 0;
    let totalNb = 0;

    for (const row of rows) {
      const v = Number(row.puis_ins_kw) || 0;
      const n = Number(row.nb_inst) || 0;
      row.puis_ins_kw = v;
      row.nb_inst = n;
      totalKw += v;
      totalNb += n;
    }

    return { totalKw, totalNb, perIris: rows };
  }

  async function fetchIrradianceSeries(lat, lon, tiltDeg, azimuthDeg, pastHours, forecastHours) {
    const params = new URLSearchParams({
      latitude: String(lat),
      longitude: String(lon),
      hourly: "global_tilted_irradiance",
      tilt: String(tiltDeg),
      azimuth: String(azimuthDeg),
      timeformat: "iso8601",
      timezone: "Europe/Paris",
      time_resolution: "native",
      past_hours: String(pastHours),
      forecast_hours: String(forecastHours),
    });

    const url = `${OPEN_METEO_BASE}?${params.toString()}`;
    const json = await fetchJson(url);

    const times = json.hourly?.time || [];
    const gti = json.hourly?.global_tilted_irradiance || [];

    if (times.length !== gti.length) {
      console.warn("Open-Meteo: timestamps != irradiance values:", times.length, gti.length);
    }

    const expectedTotal = pastHours + forecastHours;
    if (times.length !== expectedTotal) {
      console.warn("Open-Meteo: unexpected series length:", "expected", expectedTotal, "got", times.length);
    }

    const totalToUse = Math.min(expectedTotal, times.length, gti.length);
    const splitIndex = Math.min(pastHours, totalToUse);

    const past = [];
    const forecast = [];

    for (let i = 0; i < totalToUse; i++) {
      const tIso = times[i];
      const v = gti[i];
      if (v == null) continue;

      const point = { time: tIso, gti_w_per_m2: v };
      if (i < splitIndex) past.push(point);
      else forecast.push(point);
    }

    return { past, forecast };
  }

  async function fetchTemperatureSeries(lat, lon, pastHours, forecastHours) {
    const params = new URLSearchParams({
      latitude: String(lat),
      longitude: String(lon),
      hourly: "temperature_2m",
      timeformat: "iso8601",
      timezone: "Europe/Paris",
      past_hours: String(pastHours),
      forecast_hours: String(forecastHours),
    });

    const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
    const json = await fetchJson(url);

    const times = json.hourly?.time || [];
    const temps = json.hourly?.temperature_2m || [];

    const expected = pastHours + forecastHours;
    const total = Math.min(times.length, temps.length, expected);
    const split = Math.min(pastHours, total);

    const past = [];
    const forecast = [];

    for (let i = 0; i < total; i++) {
      const t = temps[i];
      if (t == null) continue;
      const entry = { time: times[i], t_air_c: t };
      if (i < split) past.push(entry);
      else forecast.push(entry);
    }

    return { past, forecast };
  }

  // ------------
  // Data preparation (hist + rt)
  // ------------

  function computeIrisLists() {
    const pvCodes = new Set();
    const consoCodes = new Set();

    for (const yr of hist.years) {
      const pvRows = hist.pvByYear[yr] || [];
      for (const row of pvRows) pvCodes.add(row.codeiris);

      const consoRows = hist.consoByYear[yr] || [];
      for (const row of consoRows) consoCodes.add(row.codeiris);
    }

    const sortIris = (a, b) => {
      if (a === null) return -1;
      if (b === null) return 1;
      return Number(a) - Number(b);
    };

    hist.pvIrisList = Array.from(pvCodes).sort(sortIris);
    hist.consoIrisList = Array.from(consoCodes).sort(sortIris);
  }

  function buildConsumptionIndexes() {
    // Build:
    // - hist.consoIndexByYear[year] = Map(codeiris -> { total, byFiliere: Map })
    // - hist.consoFilieres = stable sorted list of filiere labels appearing in the selected year range
    const filieres = new Set();
    hist.consoIndexByYear = {};

    for (const yr of hist.years) {
      const rows = hist.consoByYear[yr] || [];
      const byIris = new Map();

      for (const r of rows) {
        const code = (r.codeiris === undefined) ? null : r.codeiris;
        const fil = r.filiere || "Inconnu";
        filieres.add(fil);

        if (!byIris.has(code)) byIris.set(code, { total: 0, byFiliere: new Map() });
        const entry = byIris.get(code);

        const v = Number(r.conso_totale_kwh) || 0;
        entry.total += v;
        entry.byFiliere.set(fil, (entry.byFiliere.get(fil) || 0) + v);
      }

      hist.consoIndexByYear[yr] = byIris;
    }

    hist.consoFilieres = Array.from(filieres).sort((a, b) => a.localeCompare(b));
  }

  function getValue(row, metricKey) {
    const v = row[metricKey];
    if (v === null || v === undefined) return 0;
    return Number(v) || 0;
  }

  function computePowerSeriesKw(irrSeries, totalKw) {
    return irrSeries.map((pt) => {
      const frac = pt.gti_w_per_m2 / 1000.0;
      return { time: pt.time, power_kw: CALIB_K * totalKw * frac };
    });
  }

  function computePersonalSeriesForArray(arr, irrSeries, tempSeries) {
    const p_kwc = Number(arr.p_kwc) || 0;
    const perf_factor = Number(arr.perf_factor) || 0;

    const mapTemp = new Map(tempSeries.map((pt) => [pt.time, pt.t_air_c]));
    const result = [];

    for (const pt of irrSeries) {
      const G = pt.gti_w_per_m2 || 0;
      const Tair = mapTemp.get(pt.time);
      if (Tair == null) continue;

      const Tpanel = Tair + ((NOCT - 20) / 800) * G;
      const frac = G / 1000.0;
      const tempFactor = Math.max(0, 1 + GAMMA * (Tpanel - 25));
      const powerKw = p_kwc * frac * perf_factor * tempFactor;

      result.push({ time: pt.time, power_kw: powerKw, t_panel_c: Tpanel });
    }

    return result;
  }

  function clamp(v, lo, hi) {
    v = Number(v);
    if (Number.isNaN(v)) return lo;
    return Math.min(hi, Math.max(lo, v));
  }

  function makeNewPersonalArray(nextIndex) {
    return {
      id: `arr${Date.now()}_${Math.floor(Math.random() * 1e6)}`,
      name: `Champ ${nextIndex}`,
      p_kwc: 3.0,
      tilt_deg: PANEL_TILT_DEG,
      azimuth_deg: PANEL_AZIMUTH_DEG,
      perf_factor: 0.85,
      irrPast: [],
      irrForecast: [],
    };
  }

  // ------------
  // Chart building
  // ------------

  function buildHistDatasets(metricKey, mode) {
    const metricDef = HIST_METRICS[metricKey];

    // PV metrics
    if (metricDef?.source === "pv") {
      if (mode === "total") {
        const values = hist.years.map((yr) => {
          const rows = hist.pvByYear[yr] || [];
          return rows.reduce((sum, row) => sum + getValue(row, metricKey), 0);
        });
        return {
          datasets: [{ label: `Total ${NAME_COMMUNE}`, data: values, stack: "stack1" }],
          metricLabel: metricDef.label,
          metricUnit: metricDef.unit,
        };
      }

      const datasets = hist.pvIrisList.map((code) => {
        const values = hist.years.map((yr) => {
          const rows = hist.pvByYear[yr] || [];
          const row = rows.find((r) => r.codeiris === code);
          return row ? getValue(row, metricKey) : 0;
        });
        return { label: irisDisplayName(code), data: values, stack: "stack1" };
      });

      return { datasets, metricLabel: metricDef.label, metricUnit: metricDef.unit };
    }

    // Consumption metric
    if (metricDef?.source === "conso") {
      if (mode === "total") {
        // Stacked: one dataset per filiere (Electricité / Gaz)
        const filieres = hist.consoFilieres || [];
        const datasets = filieres.map((fil) => {
          const values = hist.years.map((yr) => {
            const rows = hist.consoByYear[yr] || [];
            let s = 0;
            for (const r of rows) if ((r.filiere || "") === fil) s += Number(r.conso_totale_kwh) || 0;
            return s;
          });
          return { label: fil, data: values, stack: "stack1" };
        });
        return { datasets, metricLabel: metricDef.label, metricUnit: metricDef.unit };
      }

      // IRIS mode: keep the same visual shape as PV (one dataset per IRIS),
      // but sum over filiere; put filiere breakdown in tooltip.
      const datasets = hist.consoIrisList.map((code) => {
        const values = hist.years.map((yr) => {
          const byIris = hist.consoIndexByYear?.[yr];
          const entry = byIris ? byIris.get(code) : null;
          return entry ? (Number(entry.total) || 0) : 0;
        });
        return { label: irisDisplayName(code), data: values, stack: "stack1", _codeiris: code };
      });

      return { datasets, metricLabel: metricDef.label, metricUnit: metricDef.unit };
    }

    // Fallback (shouldn't happen)
    return { datasets: [], metricLabel: metricDef?.label || metricKey, metricUnit: metricDef?.unit || "" };
  }

  function intersectTimesSorted(seriesList) {
    // seriesList: array of arrays of points: [{time:..}, ...]
    if (!Array.isArray(seriesList) || seriesList.length === 0) return [];

    let common = null;
    for (const series of seriesList) {
      const s = new Set((series || []).map(p => p.time));
      common = common == null ? s : new Set([...common].filter(t => s.has(t)));
      if (!common.size) break;
    }

    // Times are ISO8601, lexical sort is chronological.
    return Array.from(common || []).sort();
  }

  function buildTimeline(pastLists, forecastLists) {
    const pastTimes = intersectTimesSorted(pastLists || []);
    const cutoff = pastTimes.length ? pastTimes[pastTimes.length - 1] : null;

    let forecastTimes = intersectTimesSorted(forecastLists || []);

    if (cutoff) forecastTimes = forecastTimes.filter(t => t > cutoff);

    const labels = pastTimes.concat(forecastTimes);
    return { pastTimes, forecastTimes, labels, nPast: pastTimes.length, cutoff };
  }

  function extractByTimes(series, times) {
    const map = new Map((series || []).map(p => [p.time, p]));
    return (times || []).map(t => map.get(t)).filter(Boolean);
  }

  function mergeByTimes(pastSeries, forecastSeries, pastTimes, forecastTimes) {
    return extractByTimes(pastSeries, pastTimes)
      .concat(extractByTimes(forecastSeries, forecastTimes));
  }

  function forecastSegment(nPast) {
    return {
      segment: {
        borderDash: (ctx) => (ctx.p1DataIndex >= nPast ? [5, 5] : undefined),
      },
    };
  }

  function buildRealtimeDatasets(mode, showForecast) {
    // TOTAL
    if (mode === "total") {
      const tl = buildTimeline([rt.irrPastCommune || []], showForecast ? [rt.irrForecastCommune || []] : []);
      const irrMerged = mergeByTimes(rt.irrPastCommune, rt.irrForecastCommune, tl.pastTimes, tl.forecastTimes);

      const series = computePowerSeriesKw(irrMerged, rt.capTotalKw);
      const data = series.map(p => p.power_kw);

      return {
        labels: tl.labels,
        datasets: [{
          label: "Puissance produite",
          data,
          borderWidth: 2,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-total",
          showInLegend: true,
          _forecastStartIndex: tl.nPast,
          ...forecastSegment(tl.nPast),
        }],
      };
    }

    // IRIS
    if (mode === "iris") {
      const tl = buildTimeline([rt.irrPastCommune || []], showForecast ? [rt.irrForecastCommune || []] : []);
      const irrMerged = mergeByTimes(rt.irrPastCommune, rt.irrForecastCommune, tl.pastTimes, tl.forecastTimes);

      const datasets = [];

      for (const row of rt.capPerIris || []) {
        const capKw = Number(row.puis_ins_kw) || 0;
        if (capKw <= 0) continue;

        const codeiris = row.codeiris === undefined ? null : row.codeiris;
        const name = irisDisplayName(codeiris);

        const data = irrMerged.map(pt => CALIB_K * capKw * ((pt.gti_w_per_m2 || 0) / 1000.0));

        datasets.push({
          label: name,
          data,
          borderWidth: 1,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-iris",
          showInLegend: true,
          _forecastStartIndex: tl.nPast,
          ...forecastSegment(tl.nPast),
        });
      }

      return { labels: tl.labels, datasets };
    }

    // PERSONAL
    if (mode === "personal") {
      const arrays = (rt.personalArrays || []).slice();

      const tl = buildTimeline(
        [rt.tempPast || [], ...arrays.map(a => a.irrPast || [])],
        showForecast ? [rt.tempForecast || [], ...arrays.map(a => a.irrForecast || [])] : []
      );

      const tempMerged = mergeByTimes(rt.tempPast, rt.tempForecast, tl.pastTimes, tl.forecastTimes);

      const datasets = [];

      for (const arr of arrays) {
        const irrMerged = mergeByTimes(arr.irrPast, arr.irrForecast, tl.pastTimes, tl.forecastTimes);
        const pts = computePersonalSeriesForArray(arr, irrMerged, tempMerged);

        datasets.push({
          label: arr.name || "Champ",
          baseLabel: arr.name || "Champ",
          data: pts.map(p => p.power_kw),
          panelTemps: pts.map(p => p.t_panel_c),
          borderWidth: 1.5,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-personal",
          showInLegend: true,
          _forecastStartIndex: tl.nPast,
          ...forecastSegment(tl.nPast),
        });
      }

      return { labels: tl.labels, datasets };
    }
  }

  function formatNumber(value, digits = 0) {
    const n = Number(value || 0);
    return new Intl.NumberFormat(undefined, { maximumFractionDigits: digits }).format(n);
  }

  function createOrUpdateHistChart(metricKey) {
    if (!dom.histCanvas) return;
    const ctx = dom.histCanvas.getContext("2d");
    const mode = dom.hModeSelect ? dom.hModeSelect.value : "iris";

    const { datasets, metricLabel, metricUnit } = buildHistDatasets(metricKey, mode);
    const yLabel = metricUnit ? `${metricLabel} (${metricUnit})` : metricLabel;

    const isConso = (HIST_METRICS?.[metricKey]?.source === "conso");
    const stacked = isConso || (mode === "iris")

    const tooltipCallbacks = {
      label: (context) => {
        const label = context.dataset.label || "";
        const value = context.parsed.y;
        const unit = metricUnit ? ` ${metricUnit}` : "";
        return `${label}: ${formatNumber(value)}${unit}`;
      },
    };

    // Extra tooltip detail for consumption in IRIS mode:
    // show filiere breakdown in the tooltip footer.
    if (isConso && mode === "iris") {
      tooltipCallbacks.footer = (items) => {
        if (!items || !items.length) return "";
        const it = items[0];
        const year = (it?.chart?.data?.labels || [])[it.dataIndex];
        const codeiris = it?.dataset?._codeiris;
        const byIris = hist.consoIndexByYear?.[year];
        const entry = byIris ? byIris.get(codeiris) : null;
        if (!entry || !entry.byFiliere) return "";

        const lines = [];
        for (const fil of (hist.consoFilieres || [])) {
          const v = entry.byFiliere.get(fil) || 0;
          if (v > 0) lines.push(`${fil}: ${formatNumber(v)} ${metricUnit}`);
        }
        return lines.length ? lines : "";
      };
    }

    if (hist.chart) {
      hist.chart.data.labels = hist.years;
      hist.chart.data.datasets = datasets;
      hist.chart.options.plugins.title.text = metricLabel;
      hist.chart.options.scales.y.title.text = yLabel;
      hist.chart.options.scales.x.stacked = stacked;
      hist.chart.options.scales.y.stacked = stacked;
      hist.chart.options.plugins.tooltip.callbacks = tooltipCallbacks;
      hist.chart.update();
      return;
    }

    hist.chart = new Chart(ctx, {
      type: "bar",
      data: { labels: hist.years, datasets },
      options: {
        responsive: true,
        plugins: {
          title: { display: true, text: metricLabel },
          tooltip: {
            callbacks: tooltipCallbacks,
          },
        },
        scales: {
          x: { stacked },
          y: {
            stacked,
            beginAtZero: true,
            title: { display: true, text: yLabel },
          },
        },
      },
    });
  }

  function hhmmFromIso(label) {
    if (!label) return "";
    const t = String(label).split("T")[1] || String(label);
    return t.slice(0, 5);
  }

  function createOrUpdateRealtimeChart() {
    if (!dom.rtCanvas) return;
    const ctx = dom.rtCanvas.getContext("2d");

    const mode = getCurrentRealtimeMode();
    const showForecast = dom.rtForecastToggle ? dom.rtForecastToggle.checked : false;

    const { labels, datasets } = buildRealtimeDatasets(mode, showForecast);
    const stacked = (mode === "iris") || (mode === "personal" && (rt.personalArrays || []).length > 1);

    const rtMetricKey = "power_kw";
    const rtMetric = RT_METRICS[rtMetricKey];

    if (rt.chart) {
      rt.chart.data.labels = labels;
      rt.chart.data.datasets = datasets;
      rt.chart.options.plugins.title.text = rtMetric.label;
      rt.chart.options.scales.x.stacked = stacked;
      rt.chart.options.scales.y.title.text = rtMetric.axisLabel;
      rt.chart.options.scales.y.stacked = stacked;
      rt.chart.update();
    } else {
      rt.chart = new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            title: { display: true, text: rtMetric.label },
            tooltip: {
              callbacks: {
                title: (items) => {
                  if (!items || !items.length) return "";
                  const t = `Heure : ${hhmmFromIso(items[0].label)}`;
                  const isForecast = items.some(it => {
                    const start = it?.dataset?._forecastStartIndex;
                    return (typeof start === "number") && start !== null && (it.dataIndex >= start);
                  });
                  return isForecast ? `${t} (prévision)` : t;
                },
                label: (context) => {
                  const v = context.parsed.y;
                  if (v == null) return "";

                  // Default behaviour for non-personal modes
                  if (getCurrentRealtimeMode() !== "personal") return rtMetric.tooltip(v);

                  const ds = context.dataset || {};
                  const name = ds.baseLabel || ds.label || "Champ";
                  const t = (ds.panelTemps || [])[context.dataIndex];
                  let msg = `${name} : ${v.toFixed(1)} kW`;
                  if (typeof t === "number" && !Number.isNaN(t)) {
                    msg += ` (température panneau ≈ ${t.toFixed(1)} °C)`;
                  }
                  return msg;
                },
                footer: (items) => {
                  if (getCurrentRealtimeMode() !== "personal") return "";
                  if (!items || !items.length) return "";

                  const idx = items[0].dataIndex;
                  const chart = items[0].chart;
                  if (!chart) return "";

                  // Sum *all* datasets at this index (not just the hovered tooltip items)
                  // so we always get the true stacked total.
                  let total = 0;
                  for (const ds of (chart.data.datasets || [])) {
                    const v = ds?.data?.[idx];
                    if (typeof v === "number" && !Number.isNaN(v)) total += v;
                  }

                  return `Puissance totale : ${total.toFixed(1)} kW`;
                }
              },
            },
            legend: {
              labels: {
                filter: (item, data) => {
                  const ds = (data?.datasets || [])[item.datasetIndex];
                  return !(ds && ds.showInLegend === false);
                },
              },
            },
          },
          scales: {
            x: {
              type: "category",
              stacked,
              ticks: {
                callback: function (_value, index) {
                  const label = (this.chart.data.labels || [])[index] || "";
                  return hhmmFromIso(label)
                },
              },
            },
            y: {
              beginAtZero: true,
              stacked,
              title: { display: true, text: rtMetric.axisLabel },
            },
          },
        },
      });
    }

    if (mode === "personal") {
      const n = (rt.personalArrays || []).length;
      const sumPkwc = (rt.personalArrays || []).reduce((s, a) => s + (Number(a.p_kwc) || 0), 0);
      setRealtimeStatus(
        `Estimation basée sur vos paramètres (${n} champ${n > 1 ? "s" : ""}, total = ${sumPkwc.toFixed(1)} kWc). ` +
        `Mise à jour environ une fois par heure.`
      );
    } else {
      setRealtimeStatus(
        `Capacité photovoltaïque installée à ${NAME_COMMUNE} : ${rt.capTotalKw.toFixed(1)} kWc (${rt.capTotalNb} installations). ` +
        `Mise à jour environ une fois par heure.`
      );
    }
  }

  // ------------
  // Realtime refreshers
  // ------------

  async function fetchIrradianceAndTemperatureCommune() {
    const [irr, temp] = await Promise.all([
      fetchIrradianceSeries(ANT_LAT, ANT_LON, PANEL_TILT_DEG, PANEL_AZIMUTH_DEG, RT_PAST_HOURS, RT_FORECAST_HOURS),
      fetchTemperatureSeries(ANT_LAT, ANT_LON, RT_PAST_HOURS, RT_FORECAST_HOURS),
    ]);

    rt.irrPastCommune = irr.past;
    rt.irrForecastCommune = irr.forecast;
    rt.tempPast = temp.past;
    rt.tempForecast = temp.forecast;
  }

  async function fetchIrradianceForArray(arr) {
    const tilt = clamp(arr.tilt_deg, 0, 90);
    const az = clamp(arr.azimuth_deg, -180, 180);
    const irr = await fetchIrradianceSeries(
      ANT_LAT, ANT_LON,
      tilt,
      az,
      RT_PAST_HOURS, RT_FORECAST_HOURS
    );
    arr.irrPast = irr.past;
    arr.irrForecast = irr.forecast;
  }

  async function refetchAllPersonalIrradiance() {
    const arrays = rt.personalArrays || [];
    await Promise.all(arrays.map(a => fetchIrradianceForArray(a)));
  }

  function renderPersonalArrayControls() {
    if (!dom.rtArraysContainer) return;
    dom.rtArraysContainer.textContent = "";

    const arrays = rt.personalArrays || [];
    arrays.forEach((arr, idx) => {
      const row = document.createElement("div");
      row.className = "rt-array-row";

      const name = document.createElement("input");
      name.type = "text";
      name.className = "rt-array-name";
      name.value = arr.name || `Champ ${idx + 1}`;
      name.placeholder = `Champ ${idx + 1}`;
      name.title = "Nom du champ (ex. Est, Ouest, Toit garage…)";
      name.addEventListener("change", () => {
        arr.name = name.value || `Champ ${idx + 1}`;
        debouncedSavePersonalArrays();
        debouncedRealtimeChartUpdate();
      });

      function makeNumber(labelText, title, min, max, step, getVal, setVal, onChange) {
        const lab = document.createElement("label");
        lab.title = title;
        lab.appendChild(document.createTextNode(labelText + " "));
        const input = document.createElement("input");
        input.type = "number";
        if (min != null) input.min = String(min);
        if (max != null) input.max = String(max);
        if (step != null) input.step = String(step);
        input.value = String(getVal());
        input.addEventListener("input", () => {
          setVal(Number(input.value));
          onChange();
        });
        lab.appendChild(input);
        return lab;
      }

      const ensureDebouncer = () => {
        if (personalArrayDebouncers.has(arr.id)) return personalArrayDebouncers.get(arr.id);
        const d = debounce(async () => {
          try {
            await fetchIrradianceForArray(arr);
            debouncedSavePersonalArrays();
            if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
          } catch (e) {
            showError(dom.rtStatus, "Erreur lors de la mise à jour (mode personnel)", e);
          }
        }, 1000);
        personalArrayDebouncers.set(arr.id, d);
        return d;
      };

      const onNoFetchChange = () => { debouncedSavePersonalArrays(); debouncedRealtimeChartUpdate(); };
      const onNeedsFetchChange = () => ensureDebouncer()();

      const p = makeNumber(
        "Puissance (kWc)",
        "Puissance crête du champ, en kWc.",
        0, null, 0.1,
        () => arr.p_kwc,
        (v) => { arr.p_kwc = Math.max(0, Number(v) || 0); },
        onNoFetchChange
      );

      const tilt = makeNumber(
        "Inclinaison (°)",
        "0° = à plat, 90° = vertical.",
        0, 90, 1,
        () => arr.tilt_deg,
        (v) => { arr.tilt_deg = clamp(v, 0, 90); },
        onNeedsFetchChange
      );

      const az = makeNumber(
        "Azimut (°)",
        "0° = sud, négatif vers l'est, positif vers l'ouest.",
        -180, 180, 5,
        () => arr.azimuth_deg,
        (v) => { arr.azimuth_deg = clamp(v, -180, 180); },
        onNeedsFetchChange
      );

      const perf = makeNumber(
        "Rendement (%)",
        "Rendement global : pertes onduleur/câbles/ombrage etc. 80–90 % est courant.",
        10, 120, 1,
        () => Math.round((Number(arr.perf_factor) || 0) * 100),
        (v) => { arr.perf_factor = clamp(v, 10, 120) / 100.0; },
        onNoFetchChange
      );

      const del = document.createElement("button");
      del.type = "button";
      del.textContent = "Supprimer";
      del.title = "Supprimer ce champ";
      del.disabled = arrays.length <= 1;
      del.addEventListener("click", () => {
        rt.personalArrays = (rt.personalArrays || []).filter(a => a.id !== arr.id);
        personalArrayDebouncers.delete(arr.id);
        savePersonalArraysToStorage();
        renderPersonalArrayControls();
        if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
      });

      row.appendChild(name);
      row.appendChild(p);
      row.appendChild(tilt);
      row.appendChild(az);
      row.appendChild(perf);
      row.appendChild(del);
      dom.rtArraysContainer.appendChild(row);
    });
  }

  // ------------
  // Main init
  // ------------

  async function mapWithConcurrency(items, limit, mapper) {
    const results = new Array(items.length);
    let i = 0;

    const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
      while (true) {
        const idx = i++;
        if (idx >= items.length) break;
        results[idx] = await mapper(items[idx], idx);
      }
    });

    await Promise.all(workers);
    return results;
  }

  async function initHist() {
    try {
      setHistStatus("Recherche des années disponibles…");
      hist.years = await findAvailableYears();
      setHistStatus(`Années disponibles : ${hist.years.join(", ")}. Chargement des données pour ${NAME_COMMUNE}…`);

      await mapWithConcurrency(hist.years, CONCURRENCY, async (year) => {
        // Fetch PV + consumption for the same year (year range driven by PV availability).
        const [pvRows, consoRows] = await Promise.all([
          fetchCommuneYearData(year),
          fetchCommuneYearConsumptionData(year).catch(() => []), // be resilient if a year is missing
        ]);

        hist.pvByYear[year] = pvRows || [];
        hist.consoByYear[year] = consoRows || [];
      });

      computeIrisLists();
      buildConsumptionIndexes();

      setHistStatus(`Données chargées pour ${NAME_COMMUNE}. Vous pouvez changer la métrique avec le menu déroulant.`);

      const initialMetric = dom.hMetricSelect ? dom.hMetricSelect.value : "prod_an_kwh";
      createOrUpdateHistChart(initialMetric);

      if (dom.hMetricSelect) dom.hMetricSelect.addEventListener("change", () => createOrUpdateHistChart(dom.hMetricSelect.value));
      if (dom.hModeSelect) dom.hModeSelect.addEventListener("change", () => createOrUpdateHistChart(dom.hMetricSelect.value));
    } catch (err) {
      showError(dom.hStatus, "Erreur lors du chargement des données", err);
    }
  }

  async function initRealtime() {
    try {
      setRealtimeStatus("Chargement de la capacité PV et de l'irradiance…");

      const cap = await fetchCommuneCurrentInstalledCapacityKw();
      if (cap.totalKw <= 0) {
        setRealtimeStatus(`Capacité PV totale nulle ou indisponible pour ${NAME_COMMUNE}.`);
        return;
      }

      rt.capTotalKw = cap.totalKw;
      rt.capTotalNb = cap.totalNb;
      rt.capPerIris = cap.perIris || [];

      // Load any saved "Mon installation" arrays before first fetch
      loadPersonalArraysFromStorage();

      await fetchIrradianceAndTemperatureCommune();
      await refetchAllPersonalIrradiance();

      function updatePersonalControlsVisibility() {
        const mode = getCurrentRealtimeMode();
        if (dom.rtPersonalControls) dom.rtPersonalControls.style.display = (mode === "personal") ? "flex" : "none";
        if (mode === "personal") renderPersonalArrayControls();
        createOrUpdateRealtimeChart();
      }

      if (dom.rtModeSelect) dom.rtModeSelect.addEventListener("change", updatePersonalControlsVisibility);
      if (dom.rtForecastToggle) dom.rtForecastToggle.addEventListener("change", () => createOrUpdateRealtimeChart());

      if (dom.rtAddArrayBtn) {
        dom.rtAddArrayBtn.addEventListener("click", async () => {
          const nextIndex = (rt.personalArrays || []).length + 1;
          const arr = makeNewPersonalArray(nextIndex);
          // friendly default: alternate +90 / -90 for quick East/West comparison
          if (nextIndex % 2 === 0) arr.azimuth_deg = -90;
          if (nextIndex % 3 === 0) arr.azimuth_deg = +90;
          rt.personalArrays = (rt.personalArrays || []).concat([arr]);
          savePersonalArraysToStorage();
          renderPersonalArrayControls();
          try {
            await fetchIrradianceForArray(arr);
          } catch (e) {
            showError(dom.rtStatus, "Erreur lors de l'ajout du champ", e);
          }
          if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
        });
      }

      updatePersonalControlsVisibility();

      setInterval(async () => {
        try {
          await fetchIrradianceAndTemperatureCommune();
          if (getCurrentRealtimeMode() === "personal") {
            await refetchAllPersonalIrradiance();
          }
          createOrUpdateRealtimeChart();
        } catch (e) {
          showError(dom.rtStatus, "Erreur lors de la mise à jour", e);
        }
      }, RT_REFRESH_INTERVAL_MS);
    } catch (err) {
      showError(dom.rtStatus, "Erreur lors du chargement des données temps réel", err);
    }
  }

  // Run both widgets on page load.
  window.addEventListener("DOMContentLoaded", () => {
    cacheDom();
    initHist();
    initRealtime();
  });
})();
</script>

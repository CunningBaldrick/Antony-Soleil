<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0">
  <title>Antony Soleil – Widget Photovoltaïque</title>
  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
      max-width: 900px;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    label {
      font-weight: 600;
    }
    select {
      padding: 0.25rem 0.5rem;
      font-size: 0.95rem;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    canvas {
      max-width: 100%;
      margin-top: 1rem;
    }
    button {
      padding: 0.28rem 0.6rem;
      font-size: 0.95rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      background: #fafafa;
      cursor: pointer;
    }
    button:hover { background: #f2f2f2; }
    .rt-array-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.6rem;
      padding: 0.45rem 0.6rem;
      border: 1px solid #e6e6e6;
      border-radius: 0.75rem;
      background: #fff;
    }
    .rt-array-row input[type="number"] {
      width: 4rem;
      margin-left: 0.25rem;
    }
    .rt-array-name { width: 9rem; }
  </style>
</head>
<body>
  <div class="controls">
    <div>
      <label for="dep-select">Département :</label>
      <select id="dep-select"></select>
    </div>
    <div>
      <label for="commune-select">Commune :</label>
      <select id="commune-select"></select>
    </div>
  </div>

  <h2><span id="commune-name-hist">Antony</span> – historique des installations photovoltaïques</h2>

  <div class="controls">
    <div>
      <label for="h-metric-select">Afficher :</label>
      <select id="h-metric-select">
        <option value="puis_ins_kw">Puissance installée</option>
        <option value="nb_inst">Nombre d'installations</option>
        <option value="prod_an_kwh">Énergie injectée sur le réseau</option>
        <option value="conso_totale_kwh">Consommation annuelle</option>
      </select>
    </div>

    <div>
      <label for="h-mode-select">Découpage :</label>
      <select id="h-mode-select">
        <option value="iris">Par quartier (IRIS)</option>
        <option value="total">Total de la commune</option>
      </select>
    </div>
  </div>

  <div id="h-status" class="status">Chargement des données…</div>

  <canvas id="historyChart" width="800" height="400"></canvas>

  <h2><span id="commune-name-rt">Antony</span> – puissance photovoltaïque estimée (quasi temps réel)</h2>

  <div class="controls">
    <div>
      <label for="rt-mode-select">Affichage :</label>
      <select id="rt-mode-select">
        <option value="total">Total de la commune</option>
        <option value="iris">Par quartier (IRIS)</option>
        <option value="personal">Mon installation</option>
      </select>
    </div>

    <div>
      <label>
        <input type="checkbox" id="rt-forecast-toggle" checked />
        Afficher la prévision (24 h)
      </label>
    </div>

    <div id="rt-personal-controls" style="display:none; gap: 0.75rem; flex-wrap: wrap;">
      <span style="font-weight:600;">Paramètres personnels :</span>

      <div style="display:flex; flex-direction:column; gap:0.6rem; width:100%;">
        <div id="rt-arrays" style="display:flex; flex-direction:column; gap:0.6rem; width:100%;"></div>
        <div style="display:flex; align-items:center; gap:0.75rem; flex-wrap:wrap;">
          <button type="button" id="rt-add-array">+ Ajouter un champ</button>
          <span style="font-size:0.9rem; color:#555;">
            Astuce : mettez par exemple deux champs (Est / Ouest) pour visualiser la superposition.
          </span>
        </div>
      </div>
    </div>
  </div>

  <div id="rt-status" class="status">Chargement des données…</div>
  <canvas id="realtimeChart" width="800" height="300"></canvas>

<script>
(() => {
  // -------------------------
  // Configuration / constants
  // -------------------------

  const DEFAULT_COMMUNE_NAME = "Antony"; // Widget developed by Antony-Soleil
  const DEFAULT_INSEE_COMMUNE = "92002"; // Antony
  const DEFAULT_DEP_CODE = "92";         // Hauts-de-Seine

  const PANEL_TILT_DEG = 30;     // typical rooftop tilt
  const PANEL_AZIMUTH_DEG = 0;   // 0 = south
  const CALIB_K = 0.52;          // calibration factor, see calibrate.py


  const NOCT = 45;       // Nominal operating cell temperature, °C
  const GAMMA = -0.004;  // Power drop as cell temperature rises: -0.4 %/°C


  const CONCURRENCY = 4; // 4–6 is usually polite


  const RT_PAST_HOURS = 24;
  const RT_FORECAST_HOURS = 24;
  const RT_REFRESH_MINUTES = 17; // Notice new data fairly quickly, while staying polite
  const RT_REFRESH_INTERVAL_MS = RT_REFRESH_MINUTES * 60 * 1000;


  const AGENCE_ORE_BASE = "https://opendata.agenceore.fr/api/explore/v2.1/catalog/datasets";
  const ODRE_BASE = "https://odre.opendatasoft.com/api/explore/v2.1/catalog/datasets";
  const ODS_PUBLIC_BASE = "https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets";
  const OPEN_METEO_BASE = "https://satellite-api.open-meteo.com/v1/archive";


  const HIST_METRICS = {
    nb_inst: { label: "Nombre d'installations", unit: "", source: "pv" },
    puis_ins_kw: { label: "Puissance PV installée", unit: "kWc", source: "pv" },
    prod_an_kwh: { label: "Énergie annuelle injectée sur le réseau", unit: "kWh", source: "pv" },
    conso_totale_kwh: { label: "Consommation annuelle", unit: "kWh", source: "conso" },
  };

  const RT_METRICS = {
    power_kw: {
      label: "Puissance PV estimée",
      unit: "kW",
      digits: 1, // display 1 decimal
    },

    // In case we ever want to chart irradiance directly
    gti_wm2: {
      label: "Irradiance (plan incliné)",
      unit: "W/m²",
      digits: 0,
    },
  };

  // ------------
  // DOM cache
  // ------------

  const dom = {};
  const $ = (id) => document.getElementById(id);

  function cacheDom() {
    dom.depSelect = $("dep-select");
    dom.communeSelect = $("commune-select");
    dom.histTitleCommune = $("commune-name-hist");
    dom.rtTitleCommune = $("commune-name-rt");

    dom.hMetricSelect = $("h-metric-select");
    dom.hModeSelect = $("h-mode-select");
    dom.hStatus = $("h-status");
    dom.histCanvas = $("historyChart");

    dom.rtStatus = $("rt-status");
    dom.rtCanvas = $("realtimeChart");
    dom.rtModeSelect = $("rt-mode-select");
    dom.rtForecastToggle = $("rt-forecast-toggle");
    dom.rtPersonalControls = $("rt-personal-controls");

    dom.rtArraysContainer = $("rt-arrays");
    dom.rtAddArrayBtn = $("rt-add-array");
  }

  // ------------
  // State
  // ------------

  let communeUiListenersAttached = false;

  const geo = {
    departments: [],               // { depCode, depName, regName }
    communesByDep: new Map(),      // depCode -> [{ insee, name }]
  };

  const currentCommune = {
    insee: DEFAULT_INSEE_COMMUNE, // Commune or arrondissement code
    name: DEFAULT_COMMUNE_NAME,
    depCode: DEFAULT_DEP_CODE,
    depName: null,
    regName: null,
  };

  let irisLabels = Object.create(null);

  const hist = {
    years: [],
    pvByYear: {},
    consoByYear: {},
    consoIndexByYear: {}, // year -> Map(codeiris -> { total, byFiliere: Map(filiere -> value) })
    consoFilieres: [],    // stable list for total chart stacking
    pvIrisList: [],       // IRIS codes that have PV data (for PV charts)
    consoIrisList: [],    // IRIS codes that have consumption data (for conso charts)
    chart: null,
    listenersAttached: false,
  };

  const rt = {
    // Commune location
    communeLat: null,
    communeLon: null,

    // Commune irradiance
    irrPastCommune: [],
    irrForecastCommune: [],

    // Commune temperature
    tempPast: [],
    tempForecast: [],

    // Commune capacities
    capTotalKw: 0,
    capTotalNb: 0,
    capPerIris: [],

    // Personal configuration
    personalArrays: [
      {
        id: "arr1",
        name: "Champ 1",
        p_kwc: 3.0,
        tilt_deg: PANEL_TILT_DEG,
        azimuth_deg: PANEL_AZIMUTH_DEG,
        perf_factor: 0.85,
        irrPast: [],
        irrForecast: [],
      },
    ],

    chart: null,
    refreshTimerId: null,
    listenersAttached: false,
    personalLoaded: false,
  };

  const personalArrayDebouncers = new Map(); // arrayId -> debounced fn

  // ------------
  // Utilities
  // ------------

  function normalizeIrisCode(raw) {
    if (raw === undefined || raw === null) return null;
    const s = String(raw).trim();
    // A true IRIS is a 9-digit code. Turn anything else (e.g., "92002XXXX") into null.
    return /^\d{9}$/.test(s) ? Number(s) : null;
  }

  function irisDisplayName(codeiris) {
    if (codeiris === null || codeiris === undefined) return "Quartier inconnu";
    if (irisLabels[codeiris]) return irisLabels[codeiris];
    return `IRIS ${codeiris}`;
  }

  // Compute installed capacity for a single registre row.  Older raw data is
  // inconsistent: sometimes puismaxinstallee has a value, but sometimes only
  // puismaxrac does.  Use whichever is larger.
  function computeRegistreRowCapacityKw(row) {
    const inst = Number(row.puismaxinstallee);
    const rac  = Number(row.puismaxrac);

    const instKw = Number.isFinite(inst) && inst > 0 ? inst : 0;
    const racKw  = Number.isFinite(rac)  && rac  > 0 ? rac  : 0;

    return Math.max(instKw, racKw);
  }

  // Aggregate registre rows by IRIS, reusing the same logic for:
  //   - historical yearly data (with energy field), and
  //   - current installed capacity (capacity + nb of installations only).
  //
  // options.energyField: optional field name to sum for annual energy (e.g. "energy_kwh").
  function aggregateRegistreByIris(rows, options = {}) {
    const energyField = options.energyField || null;
    const byIris = new Map();
    let totalKw = 0;
    let totalNb = 0;

    for (const row of rows || []) {
      const iris = normalizeIrisCode(row.codeiris);
      const capKw = computeRegistreRowCapacityKw(row);
      const nb = Number(row.nbinstallations) || 0;
      const energy = energyField ? Number(row[energyField]) || 0 : 0;

      let acc = byIris.get(iris);
      if (!acc) {
        acc = {
          codeiris: iris,
          nb_inst: 0,
          puis_ins_kw: 0,
        };
        if (energyField) acc.prod_an_kwh = 0;
        byIris.set(iris, acc);
      }

      acc.nb_inst += nb;
      acc.puis_ins_kw += capKw;
      if (energyField) acc.prod_an_kwh += energy;

      totalKw += capKw;
      totalNb += nb;
    }

    const perIris = Array.from(byIris.values()).sort((a, b) => {
      if (a.codeiris === null) return -1;
      if (b.codeiris === null) return 1;
      return Number(a.codeiris) - Number(b.codeiris);
    });

    return { totalKw, totalNb, perIris };
  }

  function registreDatasetId(year) {
    const yy = String(year).slice(-2);
    return `registre-national-installation-production-stockage-electricite-agrege-3112${yy}`;
  }

  function setStatus(el, msg) {
    if (el) el.textContent = msg;
  }

  function setHistStatus(msg) {
    setStatus(dom.hStatus, msg);
  }

  function setRealtimeStatus(msg) {
    setStatus(dom.rtStatus, msg);
  }

  function showError(el, prefix, err) {
    console.error(err);
    setStatus(el, `${prefix} : ${err.message}`);
  }

  function metricAxisLabel(m) {
    if (!m) return "";
    return m.unit ? `${m.label} (${m.unit})` : m.label;
  }

  function metricFormatValue(m, v) {
    const n = Number(v);
    if (!Number.isFinite(n)) return "";
    const digits = (m && Number.isFinite(m.digits)) ? m.digits : 0;
    return new Intl.NumberFormat(undefined, {
      minimumFractionDigits: digits,
      maximumFractionDigits: digits,
    }).format(n);
  }

  function metricUnitSuffix(m) {
    return (m && m.unit) ? ` ${m.unit}` : "";
  }

  function updateCommuneTitles() {
    if (dom.histTitleCommune) dom.histTitleCommune.textContent = currentCommune.name;
    if (dom.rtTitleCommune) dom.rtTitleCommune.textContent = currentCommune.name;
    if (typeof document !== "undefined") {
      document.title = `${currentCommune.name} – Widget Photovoltaïque`;
    }
  }

  function updateCurrentCommuneDepFromCode(depCode) {
    const dep = geo.departments.find(d => d.depCode === depCode);
    if (dep) {
      currentCommune.depCode = dep.depCode;
      currentCommune.depName = dep.depName;
      currentCommune.regName = dep.regName;
    } else {
      currentCommune.depCode = depCode;
    }
  }

  function populateDepSelect() {
    if (!dom.depSelect) return;
    dom.depSelect.textContent = "";

    geo.departments.forEach(dep => {
      const opt = document.createElement("option");
      opt.value = dep.depCode;
      opt.textContent = `${dep.depCode} – ${dep.depName} (${dep.regName})`;
      dom.depSelect.appendChild(opt);
    });

    const wanted = currentCommune.depCode || (geo.departments[0] && geo.departments[0].depCode);
    if (wanted) dom.depSelect.value = wanted;
  }

  async function populateCommuneSelectForCurrentDep() {
    if (!dom.depSelect || !dom.communeSelect) return;

    const depCode = dom.depSelect.value;
    updateCurrentCommuneDepFromCode(depCode);

    const communes = await fetchCommunesInDepartment(depCode);

    dom.communeSelect.textContent = "";

    communes.forEach(c => {
      const opt = document.createElement("option");
      opt.value = c.insee;
      opt.textContent = c.name;
      dom.communeSelect.appendChild(opt);
    });

    let targetInsee = currentCommune.insee;
    if (!communes.some(c => c.insee === targetInsee)) {
      targetInsee = communes.length ? communes[0].insee : null;
    }

    if (targetInsee) {
      dom.communeSelect.value = targetInsee;
      const selected = communes.find(c => c.insee === targetInsee);
      if (selected) {
        currentCommune.insee = selected.insee;
        currentCommune.name = selected.name;
      }
    }
  }

  function attachCommuneUiListeners() {
    if (communeUiListenersAttached) return;
    communeUiListenersAttached = true;

    if (dom.depSelect) {
      dom.depSelect.addEventListener("change", () => {
        (async () => {
          try {
            await populateCommuneSelectForCurrentDep();
            updateCommuneTitles();
            saveLastCommuneToStorage();
            await reloadForCurrentCommune();
          } catch (e) {
            console.error("Erreur lors du changement de département", e);
          }
        })();
      });
    }

    if (dom.communeSelect) {
      dom.communeSelect.addEventListener("change", () => {
        (async () => {
          try {
            const insee = String(dom.communeSelect.value);
            const name =
              dom.communeSelect.selectedOptions?.[0]?.textContent?.trim() || insee;

            currentCommune.insee = insee;
            currentCommune.name = name;

            updateCommuneTitles();
            saveLastCommuneToStorage();
            await reloadForCurrentCommune();
          } catch (e) {
            console.error("Erreur lors du changement de commune", e);
          }
        })();
      });
    }
  }

  function updatePersonalControlsVisibility() {
    const mode = getCurrentRealtimeMode();
    if (dom.rtPersonalControls) {
      dom.rtPersonalControls.style.display = (mode === "personal") ? "flex" : "none";
    }
    if (mode === "personal") renderPersonalArrayControls();
    createOrUpdateRealtimeChart();
  }

  function debounce(fn, delayMs) {
    let timeoutId = null;
    return function (...args) {
      if (timeoutId !== null) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(this, args), delayMs);
    };
  }

  function getCurrentRealtimeMode() {
    return dom.rtModeSelect ? dom.rtModeSelect.value : "total";
  }

  // Debounce chart refresh so typing doesn't redraw on every keystroke.
  // Separate from the "fetch irradiance" debounce used for tilt/azimuth.
  const debouncedRealtimeChartUpdate = debounce(() => {
    if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
  }, 1000);

  // ----------------------------
  // Persistence (localStorage)
  // ----------------------------

  const LAST_COMMUNE_STORAGE_KEY = "Solar.lastCommune.v1";

  function saveLastCommuneToStorage() {
    try {
      const payload = {
        v: 1,
        savedAt: new Date().toISOString(),
        insee: String(currentCommune.insee || "").trim(),
        name: String(currentCommune.name || "").trim(),
        depCode: String(currentCommune.depCode || "").trim(),
      };
      localStorage.setItem(LAST_COMMUNE_STORAGE_KEY, JSON.stringify(payload));
    } catch (e) {
      // Ignore (private mode / blocked storage / quota)
    }
  }

  function loadLastCommuneFromStorage() {
    try {
      const raw = localStorage.getItem(LAST_COMMUNE_STORAGE_KEY);
      if (!raw) return false;

      const payload = JSON.parse(raw);
      if (!payload || payload.v !== 1) return false;

      if (typeof payload.insee === "string" && payload.insee.trim()) {
        currentCommune.insee = payload.insee.trim();
      }
      if (typeof payload.name === "string" && payload.name.trim()) {
        currentCommune.name = payload.name.trim();
      }
      if (typeof payload.depCode === "string" && payload.depCode.trim()) {
        currentCommune.depCode = payload.depCode.trim();
      }
      return true;
    } catch (e) {
      return false;
    }
  }

  const ARRAYS_STORAGE_KEY_PREFIX = "Solar.personalArrays.v1";

  function getArraysStorageKey() {
    // Store per-commune, using INSEE as the stable identifier
    return `${ARRAYS_STORAGE_KEY_PREFIX}.${currentCommune.insee}`;
  }

  function serializePersonalArrays(arrays) {
    return {
      v: 1,
      savedAt: new Date().toISOString(),
      arrays: (arrays || []).map(a => ({
        id: String(a.id || ""),
        name: String(a.name || ""),
        p_kwc: Number(a.p_kwc) || 0,
        tilt_deg: clamp(a.tilt_deg, 0, 90),
        azimuth_deg: clamp(a.azimuth_deg, -180, 180),
        perf_factor: clamp((Number(a.perf_factor) || 0) * 100, 10, 120) / 100,
      })),
    };
  }

  function restorePersonalArrays(payload) {
    const arraysIn = payload?.arrays;
    if (!Array.isArray(arraysIn) || arraysIn.length === 0) return null;

    const restored = [];
    for (const a of arraysIn) {
      const id = (a && typeof a.id === "string" && a.id.trim())
        ? a.id.trim()
        : `arr${Date.now()}_${Math.floor(Math.random() * 1e6)}`;
      restored.push({
        id,
        name: (a && typeof a.name === "string" && a.name.trim()) ? a.name.trim() : "Champ",
        p_kwc: Math.max(0, Number(a.p_kwc) || 0),
        tilt_deg: clamp(a.tilt_deg, 0, 90),
        azimuth_deg: clamp(a.azimuth_deg, -180, 180),
        perf_factor: clamp((Number(a.perf_factor) || 0) * 100, 10, 120) / 100,
        irrPast: [],
        irrForecast: [],
      });
    }
    return restored.length ? restored : null;
  }

  function savePersonalArraysToStorage() {
    try {
      const payload = serializePersonalArrays(rt.personalArrays);
      localStorage.setItem(getArraysStorageKey(), JSON.stringify(payload));
    } catch (e) {
      // Ignore (private mode / blocked storage / quota).
    }
  }

  function loadPersonalArraysFromStorage() {
    try {
      const raw = localStorage.getItem(getArraysStorageKey());
      if (!raw) return false;
      const payload = JSON.parse(raw);
      const restored = restorePersonalArrays(payload);
      if (!restored) return false;
      rt.personalArrays = restored;
      return true;
    } catch (e) {
      return false;
    }
  }

  const debouncedSavePersonalArrays = debounce(savePersonalArraysToStorage, 1000);

  // ------------
  // Fetch helpers
  // ------------

  async function fetchJson(url) {
    const res = await fetch(url)
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return res.json();
  }

  // Generic helper for Opendatasoft Explore v2.1 pagination.
  // baseUrl: ".../datasets/<dataset_id>/records"
  // baseParams: plain object of query parameters (where, select, group_by, order_by, etc.)
  // pageSize: per-page limit (API max is 100).
  // maxPages: safety cap to avoid infinite loops if total_count is missing or inconsistent.
  async function fetchAllExploreRecords(baseUrl, baseParams, pageSize = 100, maxPages = 20) {
    const all = [];
    let offset = 0;
    let totalCount = null;

    for (let page = 0; page < maxPages; page++) {
      const params = new URLSearchParams(baseParams || {});
      params.set("limit", String(pageSize));
      if (offset > 0) params.set("offset", String(offset));

      const url = `${baseUrl}?${params.toString()}`;
      const json = await fetchJson(url);
      const rows = json.results || [];

      all.push(...rows);

      const got = rows.length;
      if (typeof json.total_count === "number") {
        totalCount = json.total_count;
      }

      // Stop when:
      // - we got less than a full page, or
      // - total_count says we've fetched everything.
      if (got < pageSize) break;
      if (totalCount != null && all.length >= totalCount) break;

      offset += got;
    }

    return all;
  }

  async function fetchDepartments() {
    const datasetId = "georef-france-commune-arrondissement-municipal";
    const base = `${ODS_PUBLIC_BASE}/${datasetId}/records`;

    const baseParams = {
      select: "dep_code, dep_name, reg_name",
      group_by: "dep_code, dep_name, reg_name",
      order_by: "dep_code",
    };

    const rows = await fetchAllExploreRecords(base, baseParams, 100);

    return rows.map(r => ({
      depCode: r.dep_code,
      depName: r.dep_name,
      regName: r.reg_name,
    }));
  }

  async function fetchCommunesInDepartment(depCode) {
    if (geo.communesByDep.has(depCode)) {
      return geo.communesByDep.get(depCode);
    }

    const datasetId = "georef-france-commune-arrondissement-municipal";
    const base = `${ODS_PUBLIC_BASE}/${datasetId}/records`;

    const baseParams = {
      where: `dep_code='${depCode}'`,
      select: "com_arm_code, com_arm_name",
      order_by: "com_arm_name",
    };

    const rows = await fetchAllExploreRecords(base, baseParams, 100);
    const communes = rows.map(r => ({
      insee: String(r.com_arm_code).trim(), // keep as string (important for leading zeros)
      name: String(r.com_arm_name ?? "").trim(),
    }));

    geo.communesByDep.set(depCode, communes);
    return communes;
  }

  async function datasetExists(datasetId) {
    const url = `${ODRE_BASE}/${datasetId}/records?limit=1`;
    const res = await fetch(url);
    if (res.status === 404) return false;
    if (!res.ok) throw new Error(`HTTP ${res.status} probing dataset ${datasetId}`);
    return true;
  }

  async function fetchCommuneIrisLabels(insee) {
    const datasetId = "georef-france-iris";
    const base = `${ODS_PUBLIC_BASE}/${datasetId}/records`;

    const baseParams = {
      where: `com_arm_code='${insee}'`,
      select: "iris_code, iris_name",
      order_by: "iris_code",
    };

    const rows = await fetchAllExploreRecords(base, baseParams, 100);
    const labels = Object.create(null);

    for (const row of rows) {
      const code = normalizeIrisCode(row.iris_code);
      if (code === null) continue;

      const name = String(row.iris_name ?? "").trim();
      if (!name) continue;  // let irisDisplayName handle the fallback

      labels[code] = name;
    }

    return labels;
  }

  async function findAvailableYears(firstYear = 2017, probeFromYear = 2025, maxFutureYears = 1) {
    const currentYear = new Date().getFullYear();
    const availableYears = [];

    for (let year = firstYear; year <= currentYear + maxFutureYears; year++) {
      if (year >= probeFromYear) {
        const datasetId = registreDatasetId(year);
        const exists = await datasetExists(datasetId);
        if (!exists) break;
      }
      availableYears.push(year);
    }

    if (availableYears.length === 0) throw new Error("No yearly registre datasets found");
    return availableYears;
  }

  async function fetchCommuneYearData(insee, year) {
    const datasetId = registreDatasetId(year);
    const base = `${ODRE_BASE}/${datasetId}/records`;

    // Field name changed around 2020
    const rawEnergyField =
      year < 2020 ? "energieannuelleinjectee" : "energieannuelleglissanteinjectee";

    const baseParams = {
      where: [
        `codeinseecommune='${insee}'`,
        "codefiliere='SOLAI'",
        "codetechnologie='PHOTV'",
      ].join(" AND "),
      select: [
        "codeiris",
        "nbinstallations",
        "puismaxinstallee",
        "puismaxrac",
        `${rawEnergyField} as energy_kwh`,
      ].join(", "),
      // Order by all selected fields so LIMIT/OFFSET pagination is stable even
      // without a primary key; ties are identical for our aggregation.
      order_by: "codeiris, nbinstallations, puismaxinstallee, puismaxrac, energy_kwh",
    };

    const rawRows = await fetchAllExploreRecords(base, baseParams, 100);
    const { perIris } = aggregateRegistreByIris(rawRows, { energyField: "energy_kwh" });
    return perIris;
  }

  async function fetchCommuneConsumptionData(insee, years) {
    const datasetId = "consommation-annuelle-d-electricite-et-gaz-par-iris";
    const base = `${AGENCE_ORE_BASE}/${datasetId}/records`;

    // Normalise + deduplicate years
    const yearList = Array.from(
      new Set((years || []).map((y) => Number(y)))
    ).filter((y) => Number.isFinite(y));

    if (!yearList.length) {
      return Object.create(null);
    }

    const yearLiterals = yearList.map((y) => `date'${y}'`).join(", ");

    const baseParams = {
      where: [
        `code_commune='${insee}'`,
        `annee IN (${yearLiterals})`,
      ].join(" AND "),
      select: [
        "annee",
        "code_iris AS codeiris",
        "filiere",
        "sum(conso_totale_mwh) as conso_totale_mwh",
      ].join(", "),
      group_by: "annee, code_iris, filiere",
      order_by: "annee, code_iris, filiere",
    };

    const rows = await fetchAllExploreRecords(base, baseParams, 100);

    // Bucket directly by numeric year
    const byYear = Object.create(null);

    for (const r of rows) {
      const year = Number(r.annee);
      if (!Number.isFinite(year)) continue;

      const mwh = Number(r.conso_totale_mwh) || 0;
      r.conso_totale_kwh = mwh * 1000;
      r.codeiris = normalizeIrisCode(r.codeiris);
      if (typeof r.filiere !== "string") r.filiere = String(r.filiere || "");

      if (!byYear[year]) byYear[year] = [];
      byYear[year].push(r);
    }

    return byYear;
  }

  async function fetchCommuneCurrentInstalledCapacityKw(insee) {
    const datasetId = "registre-national-installation-production-stockage-electricite-agrege";
    const base = `${ODRE_BASE}/${datasetId}/records`;

    const baseParams = {
      where: [
        `codeinseecommune='${insee}'`,
        "codefiliere='SOLAI'",
        "codetechnologie='PHOTV'",
      ].join(" AND "),
      select: [
        "codeiris",
        "nbinstallations",
        "puismaxinstallee",
        "puismaxrac",
      ].join(", "),
      // Order by all selected fields so LIMIT/OFFSET pagination is stable even
      // without a primary key; ties are identical for our aggregation.
      order_by: "codeiris, nbinstallations, puismaxinstallee, puismaxrac",
    };

    const rawRows = await fetchAllExploreRecords(base, baseParams, 100);
    const { totalKw, totalNb, perIris } = aggregateRegistreByIris(rawRows);
    return { totalKw, totalNb, perIris };
  }

  async function fetchCommuneLocation(insee) {
    const datasetId = "georef-france-commune-arrondissement-municipal";
    const base = `${ODS_PUBLIC_BASE}/${datasetId}/records`;

    const params = new URLSearchParams({
      where: `com_arm_code='${insee}'`,
      select: "geo_point_2d",
      limit: "1",
    });

    const url = `${base}?${params.toString()}`;
    const json = await fetchJson(url);
    const rows = json.results || [];

    if (!rows.length) {
      throw new Error(`Aucune commune trouvée pour le code INSEE ${insee}`);
    }

    const row = rows[0];
    const point = row.geo_point_2d;

    if (!point || typeof point.lat !== "number" || typeof point.lon !== "number") {
      throw new Error(
        `Coordonnées géographiques introuvables pour la commune ${insee}`
      );
    }

    return {
      lat: Number(point.lat),
      lon: Number(point.lon),
    };
  }

  async function fetchIrradianceSeries(lat, lon, tiltDeg, azimuthDeg, pastHours, forecastHours) {
    const params = new URLSearchParams({
      latitude: String(lat),
      longitude: String(lon),
      hourly: "global_tilted_irradiance",
      tilt: String(tiltDeg),
      azimuth: String(azimuthDeg),
      timeformat: "iso8601",
      timezone: "Europe/Paris",
      time_resolution: "native",
      past_hours: String(pastHours),
      forecast_hours: String(forecastHours),
    });

    const url = `${OPEN_METEO_BASE}?${params.toString()}`;
    const json = await fetchJson(url);

    const times = json.hourly?.time || [];
    const gti = json.hourly?.global_tilted_irradiance || [];

    if (times.length !== gti.length) {
      console.warn("Open-Meteo: timestamps != irradiance values:", times.length, gti.length);
    }

    const expectedTotal = pastHours + forecastHours;
    if (times.length !== expectedTotal) {
      console.warn("Open-Meteo: unexpected series length:", "expected", expectedTotal, "got", times.length);
    }

    const totalToUse = Math.min(expectedTotal, times.length, gti.length);
    const splitIndex = Math.min(pastHours, totalToUse);

    const past = [];
    const forecast = [];

    for (let i = 0; i < totalToUse; i++) {
      const tIso = times[i];
      const v = gti[i];
      if (v == null) continue;

      const point = { time: tIso, gti_w_per_m2: v };
      if (i < splitIndex) past.push(point);
      else forecast.push(point);
    }

    return { past, forecast };
  }

  async function fetchTemperatureSeries(lat, lon, pastHours, forecastHours) {
    const params = new URLSearchParams({
      latitude: String(lat),
      longitude: String(lon),
      hourly: "temperature_2m",
      timeformat: "iso8601",
      timezone: "Europe/Paris",
      past_hours: String(pastHours),
      forecast_hours: String(forecastHours),
    });

    const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
    const json = await fetchJson(url);

    const times = json.hourly?.time || [];
    const temps = json.hourly?.temperature_2m || [];

    const expected = pastHours + forecastHours;
    const total = Math.min(times.length, temps.length, expected);
    const split = Math.min(pastHours, total);

    const past = [];
    const forecast = [];

    for (let i = 0; i < total; i++) {
      const t = temps[i];
      if (t == null) continue;
      const entry = { time: times[i], t_air_c: t };
      if (i < split) past.push(entry);
      else forecast.push(entry);
    }

    return { past, forecast };
  }

  // ------------
  // Data preparation (hist + rt)
  // ------------

  function computeIrisLists() {
    const pvCodes = new Set();
    const consoCodes = new Set();

    for (const yr of hist.years) {
      const pvRows = hist.pvByYear[yr] || [];
      for (const row of pvRows) pvCodes.add(row.codeiris);

      const consoRows = hist.consoByYear[yr] || [];
      for (const row of consoRows) consoCodes.add(row.codeiris);
    }

    const sortIris = (a, b) => {
      if (a === null) return -1;
      if (b === null) return 1;
      return Number(a) - Number(b);
    };

    hist.pvIrisList = Array.from(pvCodes).sort(sortIris);
    hist.consoIrisList = Array.from(consoCodes).sort(sortIris);
  }

  function buildConsumptionIndexes() {
    // Build:
    // - hist.consoIndexByYear[year] = Map(codeiris -> { total, byFiliere: Map })
    // - hist.consoFilieres = stable sorted list of filiere labels appearing in the selected year range
    const filieres = new Set();
    hist.consoIndexByYear = {};

    for (const yr of hist.years) {
      const rows = hist.consoByYear[yr] || [];
      const byIris = new Map();

      for (const r of rows) {
        const code = (r.codeiris === undefined) ? null : r.codeiris;
        const fil = r.filiere || "Inconnu";
        filieres.add(fil);

        if (!byIris.has(code)) byIris.set(code, { total: 0, byFiliere: new Map() });
        const entry = byIris.get(code);

        const v = Number(r.conso_totale_kwh) || 0;
        entry.total += v;
        entry.byFiliere.set(fil, (entry.byFiliere.get(fil) || 0) + v);
      }

      hist.consoIndexByYear[yr] = byIris;
    }

    hist.consoFilieres = Array.from(filieres).sort((a, b) => a.localeCompare(b));
  }

  function getValue(row, metricKey) {
    const v = row[metricKey];
    if (v === null || v === undefined) return 0;
    return Number(v) || 0;
  }

  function computePowerSeriesKw(irrSeries, totalKw) {
    return irrSeries.map((pt) => {
      const frac = pt.gti_w_per_m2 / 1000.0;
      return { time: pt.time, power_kw: CALIB_K * totalKw * frac };
    });
  }

  function computePersonalSeriesForArray(arr, irrSeries, tempSeries) {
    const p_kwc = Number(arr.p_kwc) || 0;
    const perf_factor = Number(arr.perf_factor) || 0;

    const mapTemp = new Map(tempSeries.map((pt) => [pt.time, pt.t_air_c]));
    const result = [];

    for (const pt of irrSeries) {
      const G = pt.gti_w_per_m2 || 0;
      const Tair = mapTemp.get(pt.time);
      if (Tair == null) continue;

      const Tpanel = Tair + ((NOCT - 20) / 800) * G;
      const frac = G / 1000.0;
      const tempFactor = Math.max(0, 1 + GAMMA * (Tpanel - 25));
      const powerKw = p_kwc * frac * perf_factor * tempFactor;

      result.push({ time: pt.time, power_kw: powerKw, t_panel_c: Tpanel });
    }

    return result;
  }

  function clamp(v, lo, hi) {
    v = Number(v);
    if (Number.isNaN(v)) return lo;
    return Math.min(hi, Math.max(lo, v));
  }

  function makeNewPersonalArray(nextIndex) {
    return {
      id: `arr${Date.now()}_${Math.floor(Math.random() * 1e6)}`,
      name: `Champ ${nextIndex}`,
      p_kwc: 3.0,
      tilt_deg: PANEL_TILT_DEG,
      azimuth_deg: PANEL_AZIMUTH_DEG,
      perf_factor: 0.85,
      irrPast: [],
      irrForecast: [],
    };
  }

  // ------------
  // Chart building
  // ------------

  function buildHistDatasets(metricKey, mode) {
    const metricDef = HIST_METRICS[metricKey];

    // PV metrics
    if (metricDef?.source === "pv") {
      if (mode === "total") {
        const values = hist.years.map((yr) => {
          const rows = hist.pvByYear[yr] || [];
          return rows.reduce((sum, row) => sum + getValue(row, metricKey), 0);
        });
        return {
          datasets: [{ label: `Total ${currentCommune.name}`, data: values, stack: "stack1" }],
          metricLabel: metricDef.label,
          metricUnit: metricDef.unit,
        };
      }

      const datasets = hist.pvIrisList.map((code) => {
        const values = hist.years.map((yr) => {
          const rows = hist.pvByYear[yr] || [];
          const row = rows.find((r) => r.codeiris === code);
          return row ? getValue(row, metricKey) : 0;
        });
        return { label: irisDisplayName(code), data: values, stack: "stack1" };
      });

      return { datasets };
    }

    // Consumption metric
    if (metricDef?.source === "conso") {
      if (mode === "total") {
        // Stacked: one dataset per filiere (Electricité / Gaz)
        const filieres = hist.consoFilieres || [];
        const datasets = filieres.map((fil) => {
          const values = hist.years.map((yr) => {
            const rows = hist.consoByYear[yr] || [];
            let s = 0;
            for (const r of rows) if ((r.filiere || "") === fil) s += Number(r.conso_totale_kwh) || 0;
            return s;
          });
          return { label: fil, data: values, stack: "stack1" };
        });
        return { datasets };
      }

      // IRIS mode: keep the same visual shape as PV (one dataset per IRIS),
      // but sum over filiere; put filiere breakdown in tooltip.
      const datasets = hist.consoIrisList.map((code) => {
        const values = hist.years.map((yr) => {
          const byIris = hist.consoIndexByYear?.[yr];
          const entry = byIris ? byIris.get(code) : null;
          return entry ? (Number(entry.total) || 0) : 0;
        });
        return { label: irisDisplayName(code), data: values, stack: "stack1", _codeiris: code };
      });

      return { datasets };
    }

    // Fallback (shouldn't happen)
    return { datasets: [] };
  }

  function intersectTimesSorted(seriesList) {
    // seriesList: array of arrays of points: [{time:..}, ...]
    if (!Array.isArray(seriesList) || seriesList.length === 0) return [];

    let common = null;
    for (const series of seriesList) {
      const s = new Set((series || []).map(p => p.time));
      common = common == null ? s : new Set([...common].filter(t => s.has(t)));
      if (!common.size) break;
    }

    // Times are ISO8601, lexical sort is chronological.
    return Array.from(common || []).sort();
  }

  function buildTimeline(pastLists, forecastLists) {
    const pastTimes = intersectTimesSorted(pastLists || []);
    const cutoff = pastTimes.length ? pastTimes[pastTimes.length - 1] : null;

    let forecastTimes = intersectTimesSorted(forecastLists || []);

    if (cutoff) forecastTimes = forecastTimes.filter(t => t > cutoff);

    const labels = pastTimes.concat(forecastTimes);
    return { pastTimes, forecastTimes, labels, nPast: pastTimes.length, cutoff };
  }

  function extractByTimes(series, times) {
    const map = new Map((series || []).map(p => [p.time, p]));
    return (times || []).map(t => map.get(t)).filter(Boolean);
  }

  function mergeByTimes(pastSeries, forecastSeries, pastTimes, forecastTimes) {
    return extractByTimes(pastSeries, pastTimes)
      .concat(extractByTimes(forecastSeries, forecastTimes));
  }

  function forecastSegment(nPast) {
    return {
      segment: {
        borderDash: (ctx) => (ctx.p1DataIndex >= nPast ? [5, 5] : undefined),
      },
    };
  }

  function buildRealtimeDatasets(mode, showForecast) {
    // TOTAL
    if (mode === "total") {
      const tl = buildTimeline([rt.irrPastCommune || []], showForecast ? [rt.irrForecastCommune || []] : []);
      const irrMerged = mergeByTimes(rt.irrPastCommune, rt.irrForecastCommune, tl.pastTimes, tl.forecastTimes);

      const series = computePowerSeriesKw(irrMerged, rt.capTotalKw);
      const data = series.map(p => p.power_kw);

      return {
        labels: tl.labels,
        datasets: [{
          label: "Puissance PV estimée",
          data,
          borderWidth: 2,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: true,
          stack: "rt-total",
          showInLegend: true,
          _forecastStartIndex: tl.nPast,
          ...forecastSegment(tl.nPast),
        }],
      };
    }

    // IRIS
    if (mode === "iris") {
      const tl = buildTimeline([rt.irrPastCommune || []], showForecast ? [rt.irrForecastCommune || []] : []);
      const irrMerged = mergeByTimes(rt.irrPastCommune, rt.irrForecastCommune, tl.pastTimes, tl.forecastTimes);

      const datasets = [];

      for (const row of rt.capPerIris || []) {
        const capKw = Number(row.puis_ins_kw) || 0;
        if (capKw <= 0) continue;

        const codeiris = row.codeiris === undefined ? null : row.codeiris;
        const name = irisDisplayName(codeiris);

        const data = irrMerged.map(pt => CALIB_K * capKw * ((pt.gti_w_per_m2 || 0) / 1000.0));

        const isFirst = datasets.length === 0;
        datasets.push({
          label: name,
          data,
          borderWidth: 1,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: isFirst ? 'origin' : '-1',
          stack: "rt-iris",
          showInLegend: true,
          _forecastStartIndex: tl.nPast,
          ...forecastSegment(tl.nPast),
        });
      }

      return { labels: tl.labels, datasets };
    }

    // PERSONAL
    if (mode === "personal") {
      const arrays = (rt.personalArrays || []).slice();

      const tl = buildTimeline(
        [rt.tempPast || [], ...arrays.map(a => a.irrPast || [])],
        showForecast ? [rt.tempForecast || [], ...arrays.map(a => a.irrForecast || [])] : []
      );

      const tempMerged = mergeByTimes(rt.tempPast, rt.tempForecast, tl.pastTimes, tl.forecastTimes);

      const datasets = [];

      for (const arr of arrays) {
        const irrMerged = mergeByTimes(arr.irrPast, arr.irrForecast, tl.pastTimes, tl.forecastTimes);
        const pts = computePersonalSeriesForArray(arr, irrMerged, tempMerged);

        const isFirst = datasets.length === 0;
        datasets.push({
          label: arr.name || "Champ",
          baseLabel: arr.name || "Champ",
          data: pts.map(p => p.power_kw),
          panelTemps: pts.map(p => p.t_panel_c),
          borderWidth: 1.5,
          tension: 0.2,
          pointRadius: 0,
          pointHitRadius: 10,
          fill: isFirst ? 'origin' : '-1',
          stack: "rt-personal",
          showInLegend: true,
          _forecastStartIndex: tl.nPast,
          ...forecastSegment(tl.nPast),
        });
      }

      return { labels: tl.labels, datasets };
    }
  }

  function createOrUpdateHistChart(metricKey) {
    if (!dom.histCanvas) return;
    const ctx = dom.histCanvas.getContext("2d");
    const mode = dom.hModeSelect ? dom.hModeSelect.value : "iris";

    const metricDef = HIST_METRICS?.[metricKey] || { label: metricKey, unit: "", digits: 0 };
    const { datasets } = buildHistDatasets(metricKey, mode);
    const yLabel = metricAxisLabel(metricDef);

    const source = HIST_METRICS?.[metricKey]?.source;

    const isPv = (source === "pv");
    const isConso = (source === "conso");

    const stacked = isConso || (mode === "iris")

    const tooltipCallbacks = {
      label: (context) => {
        let label = context.dataset.label || "";

        if (
          isPv &&
          mode === "iris" &&
          label === "Quartier inconnu"
        ) {
           label += " (anonymisation ou quartier non renseigné)";
        }

        const value = context.parsed.y;
        let line = `${label}: ${metricFormatValue(metricDef, value)}${metricUnitSuffix(metricDef)}`;

        return line;
      },
    };

    // Extra tooltip detail for consumption in IRIS mode:
    // show filiere breakdown in the tooltip footer.
    if (isConso && mode === "iris") {
      tooltipCallbacks.footer = (items) => {
        if (!items || !items.length) return "";
        const it = items[0];
        const year = (it?.chart?.data?.labels || [])[it.dataIndex];
        const codeiris = it?.dataset?._codeiris;
        const byIris = hist.consoIndexByYear?.[year];
        const entry = byIris ? byIris.get(codeiris) : null;
        if (!entry || !entry.byFiliere) return "";

        const lines = [];
        for (const fil of (hist.consoFilieres || [])) {
          const v = entry.byFiliere.get(fil) || 0;
          if (v > 0) lines.push(`${fil}: ${metricFormatValue(metricDef, v)}${metricUnitSuffix(metricDef)}`);
        }
        return lines.length ? lines : "";
      };
    }

    if (hist.chart) {
      hist.chart.data.labels = hist.years;
      hist.chart.data.datasets = datasets;
      hist.chart.options.plugins.title.text = metricDef.label;
      hist.chart.options.scales.y.title.text = yLabel;
      hist.chart.options.scales.x.stacked = stacked;
      hist.chart.options.scales.y.stacked = stacked;
      hist.chart.options.plugins.tooltip.callbacks = tooltipCallbacks;
      hist.chart.update();
      return;
    }

    hist.chart = new Chart(ctx, {
      type: "bar",
      data: { labels: hist.years, datasets },
      options: {
        responsive: true,
        plugins: {
          title: { display: true, text: metricDef.label },
          tooltip: {
            callbacks: tooltipCallbacks,
          },
        },
        scales: {
          x: { stacked },
          y: {
            stacked,
            beginAtZero: true,
            title: { display: true, text: yLabel },
          },
        },
      },
    });
  }

  function hhmmFromIso(label) {
    if (!label) return "";
    const t = String(label).split("T")[1] || String(label);
    return t.slice(0, 5);
  }

  function formatCommuneLocation() {
    const lat = rt.communeLat;
    const lon = rt.communeLon;

    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return "";
    // 4 decimals ≈ 10–20 m, plenty for sanity-checking
    return `lat=${lat.toFixed(4)}, lon=${lon.toFixed(4)}`;
  }

  function createOrUpdateRealtimeChart() {
    if (!dom.rtCanvas) return;
    const ctx = dom.rtCanvas.getContext("2d");

    const mode = getCurrentRealtimeMode();
    const showForecast = dom.rtForecastToggle ? dom.rtForecastToggle.checked : false;

    const { labels, datasets } = buildRealtimeDatasets(mode, showForecast);
    const stacked = (mode === "iris") || (mode === "personal" && (rt.personalArrays || []).length > 1);

    const rtMetricKey = "power_kw";
    const rtMetric = RT_METRICS[rtMetricKey];
    const yAxisLabel = metricAxisLabel(rtMetric);

    if (rt.chart) {
      rt.chart.data.labels = labels;
      rt.chart.data.datasets = datasets;
      rt.chart.options.plugins.title.text = rtMetric.label;
      rt.chart.options.scales.x.stacked = stacked;
      rt.chart.options.scales.y.title.text = yAxisLabel;
      rt.chart.options.scales.y.stacked = stacked;
      rt.chart.update();
    } else {
      rt.chart = new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            title: { display: true, text: rtMetric.label },
            tooltip: {
              itemSort: (a, b) => b.datasetIndex - a.datasetIndex,
              callbacks: {
                title: (items) => {
                  if (!items || !items.length) return "";
                  const t = `Heure : ${hhmmFromIso(items[0].label)}`;
                  const isForecast = items.some(it => {
                    const start = it?.dataset?._forecastStartIndex;
                    return (typeof start === "number") && start !== null && (it.dataIndex >= start);
                  });
                  return isForecast ? `${t} (prévision)` : t;
                },
                label: (context) => {
                  const v = context.parsed.y;
                  if (v == null) return "";

                  const ds = context.dataset || {};
                  const seriesName = ds.baseLabel || ds.label || "";

                  // Value formatted from metric + unit appended once
                  const valueTxt = metricFormatValue(rtMetric, v);
                  const unitTxt = metricUnitSuffix(rtMetric);

                  // Personal mode: add panel temperature (keep your existing feature)
                  if (getCurrentRealtimeMode() === "personal") {
                    const t = (ds.panelTemps || [])[context.dataIndex];
                    let msg = `${seriesName} : ${valueTxt}${unitTxt}`;
                    if (typeof t === "number" && Number.isFinite(t)) {
                      msg += ` (température du panneau ≈ ${t.toFixed(1)} °C)`;
                    }
                    return msg;
                  }

                  // Total / IRIS mode: series label is meaningful (total or IRIS name)
                  return `${seriesName} : ${valueTxt}${unitTxt}`;
                },
                footer: (items) => {
                  if (getCurrentRealtimeMode() !== "personal") return "";
                  if (!items || !items.length) return "";

                  const idx = items[0].dataIndex;
                  const chart = items[0].chart;
                  if (!chart) return "";

                  // Sum *all* datasets at this index (not just the hovered tooltip items)
                  // so we always get the true stacked total.
                  let total = 0;
                  for (const ds of (chart.data.datasets || [])) {
                    const v = ds?.data?.[idx];
                    if (typeof v === "number" && !Number.isNaN(v)) total += v;
                  }

                  return `Puissance totale : ${metricFormatValue(rtMetric, total)}${metricUnitSuffix(rtMetric)}`;
                }
              },
            },
            legend: {
              labels: {
                filter: (item, data) => {
                  const ds = (data?.datasets || [])[item.datasetIndex];
                  return !(ds && ds.showInLegend === false);
                },
              },
            },
          },
          scales: {
            x: {
              type: "category",
              stacked,
              ticks: {
                callback: function (_value, index) {
                  const label = (this.chart.data.labels || [])[index] || "";
                  return hhmmFromIso(label)
                },
              },
            },
            y: {
              beginAtZero: true,
              stacked,
              title: { display: true, text: yAxisLabel},
            },
          },
        },
      });
    }

    if (mode === "personal") {
      const n = (rt.personalArrays || []).length;
      const sumPkwc = (rt.personalArrays || []).reduce((s, a) => s + (Number(a.p_kwc) || 0), 0);
      const locString = formatCommuneLocation();
      setRealtimeStatus(
        `Estimation basée sur vos paramètres (${n} champ${n > 1 ? "s" : ""}, ` +
        `total = ${sumPkwc.toFixed(1)} kWc, ${locString}). ` +
        `Mise à jour environ une fois par heure.`
      );
    } else {
      setRealtimeStatus(
        `Capacité photovoltaïque installée à ${currentCommune.name} : ` +
        `${rt.capTotalKw.toFixed(1)} kWc (${rt.capTotalNb} installations). ` +
        `Mise à jour environ une fois par heure.`
      );
    }
  }

  // ------------
  // Realtime refreshers
  // ------------

  async function fetchIrradianceAndTemperatureCommune() {
    if (rt.communeLat == null || rt.communeLon == null) return;

    const [irr, temp] = await Promise.all([
      fetchIrradianceSeries(rt.communeLat, rt.communeLon,
                            PANEL_TILT_DEG, PANEL_AZIMUTH_DEG,
                            RT_PAST_HOURS, RT_FORECAST_HOURS),
      fetchTemperatureSeries(rt.communeLat, rt.communeLon,
                             RT_PAST_HOURS, RT_FORECAST_HOURS),
    ]);

    rt.irrPastCommune = irr.past;
    rt.irrForecastCommune = irr.forecast;
    rt.tempPast = temp.past;
    rt.tempForecast = temp.forecast;
  }

  async function fetchIrradianceForArray(arr) {
    if (rt.communeLat == null || rt.communeLon == null) return;

    const tilt = clamp(arr.tilt_deg, 0, 90);
    const az = clamp(arr.azimuth_deg, -180, 180);
    const irr = await fetchIrradianceSeries(
      rt.communeLat, rt.communeLon,
      tilt,
      az,
      RT_PAST_HOURS, RT_FORECAST_HOURS
    );
    arr.irrPast = irr.past;
    arr.irrForecast = irr.forecast;
  }

  async function refetchAllPersonalIrradiance() {
    const arrays = rt.personalArrays || [];
    await Promise.all(arrays.map(a => fetchIrradianceForArray(a)));
  }

  function renderPersonalArrayControls() {
    if (!dom.rtArraysContainer) return;
    dom.rtArraysContainer.textContent = "";

    const arrays = rt.personalArrays || [];
    arrays.forEach((arr, idx) => {
      const row = document.createElement("div");
      row.className = "rt-array-row";

      const name = document.createElement("input");
      name.type = "text";
      name.className = "rt-array-name";
      name.value = arr.name || `Champ ${idx + 1}`;
      name.placeholder = `Champ ${idx + 1}`;
      name.title = "Nom du champ (ex. Est, Ouest, toit du garage…)";
      name.addEventListener("change", () => {
        arr.name = name.value || `Champ ${idx + 1}`;
        debouncedSavePersonalArrays();
        debouncedRealtimeChartUpdate();
      });

      function makeNumber(labelText, title, min, max, step, getVal, setVal, onChange) {
        const lab = document.createElement("label");
        lab.title = title;
        lab.appendChild(document.createTextNode(labelText + " "));
        const input = document.createElement("input");
        input.type = "number";
        if (min != null) input.min = String(min);
        if (max != null) input.max = String(max);
        if (step != null) input.step = String(step);
        input.value = String(getVal());
        input.addEventListener("input", () => {
          setVal(Number(input.value));
          onChange();
        });
        lab.appendChild(input);
        return lab;
      }

      const ensureDebouncer = () => {
        if (personalArrayDebouncers.has(arr.id)) return personalArrayDebouncers.get(arr.id);
        const d = debounce(async () => {
          try {
            await fetchIrradianceForArray(arr);
            debouncedSavePersonalArrays();
            if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
          } catch (e) {
            showError(dom.rtStatus, "Erreur lors de la mise à jour (mode personnel)", e);
          }
        }, 1000);
        personalArrayDebouncers.set(arr.id, d);
        return d;
      };

      const onNoFetchChange = () => { debouncedSavePersonalArrays(); debouncedRealtimeChartUpdate(); };
      const onNeedsFetchChange = () => ensureDebouncer()();

      const p = makeNumber(
        "Puissance (kWc)",
        "Puissance crête du champ, en kWc.",
        0, null, 0.1,
        () => arr.p_kwc,
        (v) => { arr.p_kwc = Math.max(0, Number(v) || 0); },
        onNoFetchChange
      );

      const tilt = makeNumber(
        "Inclinaison (°)",
        "0° = à plat, 90° = vertical.",
        0, 90, 1,
        () => arr.tilt_deg,
        (v) => { arr.tilt_deg = clamp(v, 0, 90); },
        onNeedsFetchChange
      );

      const az = makeNumber(
        "Azimut (°)",
        "0° = sud, négatif vers l'est, positif vers l'ouest.",
        -180, 180, 5,
        () => arr.azimuth_deg,
        (v) => { arr.azimuth_deg = clamp(v, -180, 180); },
        onNeedsFetchChange
      );

      const perf = makeNumber(
        "Rendement (%)",
        "Rendement global : pertes onduleur/câbles/ombrage etc. 80–90 % est courant.",
        10, 120, 1,
        () => Math.round((Number(arr.perf_factor) || 0) * 100),
        (v) => { arr.perf_factor = clamp(v, 10, 120) / 100.0; },
        onNoFetchChange
      );

      const del = document.createElement("button");
      del.type = "button";
      del.textContent = "Supprimer";
      del.title = "Supprimer ce champ";
      del.disabled = arrays.length <= 1;
      del.addEventListener("click", () => {
        rt.personalArrays = (rt.personalArrays || []).filter(a => a.id !== arr.id);
        personalArrayDebouncers.delete(arr.id);
        savePersonalArraysToStorage();
        renderPersonalArrayControls();
        if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
      });

      row.appendChild(name);
      row.appendChild(p);
      row.appendChild(tilt);
      row.appendChild(az);
      row.appendChild(perf);
      row.appendChild(del);
      dom.rtArraysContainer.appendChild(row);
    });
  }

  // ------------
  // Main init
  // ------------

  async function mapWithConcurrency(items, limit, mapper) {
    const results = new Array(items.length);
    let i = 0;

    const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
      while (true) {
        const idx = i++;
        if (idx >= items.length) break;
        results[idx] = await mapper(items[idx], idx);
      }
    });

    await Promise.all(workers);
    return results;
  }

  async function initCommuneData() {
    try {
      irisLabels = await fetchCommuneIrisLabels(currentCommune.insee);
    } catch (e) {
      console.warn("Impossible de charger les noms d'IRIS :", e);
      irisLabels = Object.create(null); // irisDisplayName will fall back
    }
  }

  async function initOrReloadHist() {
    try {
      setHistStatus("Recherche des années disponibles…");
      hist.years = await findAvailableYears();

      setHistStatus(
        `Années disponibles : ${hist.years.join(", ")}. ` +
        `Chargement des données pour ${currentCommune.name}…`
      );

      // Start the consumption fetch
      const consoPromise = fetchCommuneConsumptionData(
        currentCommune.insee,
        hist.years
      ).catch(() => Object.create(null));

      // In parallel, load PV for each year
      await mapWithConcurrency(hist.years, CONCURRENCY, async (year) => {
        const pvRows = await fetchCommuneYearData(currentCommune.insee, year);
        hist.pvByYear[year] = pvRows || [];
      });

      // Await the consumption result
      const consoByYear = await consoPromise;

      for (const y of hist.years) {
        hist.consoByYear[y] = consoByYear[y] || [];
      }

      computeIrisLists();
      buildConsumptionIndexes();

      setHistStatus(
        `Données chargées pour ${currentCommune.name}. ` +
        "Vous pouvez changer l’indicateur avec le menu déroulant."
      );

      const initialMetric = dom.hMetricSelect ? dom.hMetricSelect.value : "prod_an_kwh";
      createOrUpdateHistChart(initialMetric);

      if (!hist.listenersAttached) {
        if (dom.hMetricSelect) {
          dom.hMetricSelect.addEventListener("change", () =>
            createOrUpdateHistChart(dom.hMetricSelect.value)
          );
        }
        if (dom.hModeSelect) {
          dom.hModeSelect.addEventListener("change", () =>
            createOrUpdateHistChart(dom.hMetricSelect.value)
          );
        }
        hist.listenersAttached = true;
      }
    } catch (err) {
      showError(dom.hStatus, "Erreur lors du chargement des données", err);
    }
  }

  async function initOrReloadRealtime() {
    try {
      setRealtimeStatus("Chargement des coordonnées géographiques…");

      const { lat, lon } = await fetchCommuneLocation(currentCommune.insee);
      rt.communeLat = lat;
      rt.communeLon = lon;

      setRealtimeStatus("Chargement de la capacité PV…");

      const cap = await fetchCommuneCurrentInstalledCapacityKw(currentCommune.insee);

      rt.capTotalKw = cap.totalKw || 0;
      rt.capTotalNb = cap.totalNb || 0;
      rt.capPerIris = cap.perIris || [];

      if (!rt.personalLoaded) {
        loadPersonalArraysFromStorage();
        rt.personalLoaded = true;
      }

      setRealtimeStatus("Chargement des données météo…");

      await fetchIrradianceAndTemperatureCommune();
      await refetchAllPersonalIrradiance();

      if (!rt.listenersAttached) {
        if (dom.rtModeSelect) {
          dom.rtModeSelect.addEventListener("change", updatePersonalControlsVisibility);
        }
        if (dom.rtForecastToggle) {
          dom.rtForecastToggle.addEventListener("change", () => createOrUpdateRealtimeChart());
        }
        if (dom.rtAddArrayBtn) {
          dom.rtAddArrayBtn.addEventListener("click", async () => {
            const nextIndex = (rt.personalArrays || []).length + 1;
            const arr = makeNewPersonalArray(nextIndex);
            if (nextIndex % 2 === 0) arr.azimuth_deg = -90;
            if (nextIndex % 3 === 0) arr.azimuth_deg = +90;
            rt.personalArrays = (rt.personalArrays || []).concat([arr]);
            savePersonalArraysToStorage();
            renderPersonalArrayControls();
            try {
              await fetchIrradianceForArray(arr);
            } catch (e) {
              showError(dom.rtStatus, "Erreur lors de l'ajout du champ", e);
            }
            if (getCurrentRealtimeMode() === "personal") createOrUpdateRealtimeChart();
          });
        }
        rt.listenersAttached = true;
      }

      updatePersonalControlsVisibility();

      // For communes with zero capacity, we still want the chart and status
      // to reflect that, not keep the previous commune.
      if (rt.capTotalKw <= 0) {
        setRealtimeStatus(
          `Capacité photovoltaïque totale nulle ou indisponible pour ${currentCommune.name}.`
        );
      }

      if (!rt.refreshTimerId) {
        rt.refreshTimerId = setInterval(async () => {
          try {
            await fetchIrradianceAndTemperatureCommune();
            if (getCurrentRealtimeMode() === "personal") {
              await refetchAllPersonalIrradiance();
            }
            createOrUpdateRealtimeChart();
          } catch (e) {
            showError(dom.rtStatus, "Erreur lors de la mise à jour", e);
          }
        }, RT_REFRESH_INTERVAL_MS);
      }
    } catch (err) {
      showError(dom.rtStatus, "Erreur lors du chargement des données temps réel", err);
    }
  }

  async function reloadForCurrentCommune() {
    updateCommuneTitles();
    await initCommuneData();

    await Promise.all([
      initOrReloadHist(),
      initOrReloadRealtime(),
    ]);
  }

  async function initGeoUi() {
    try {
      geo.departments = await fetchDepartments();
      populateDepSelect();
      await populateCommuneSelectForCurrentDep();
      attachCommuneUiListeners();
    } catch (e) {
      console.error("Erreur lors de l'initialisation des communes :", e);
      // Fall back on the default commune
    }
  }

  window.addEventListener("DOMContentLoaded", async () => {
    cacheDom();

    loadLastCommuneFromStorage();

    updateCommuneTitles();
    const initialLoad = reloadForCurrentCommune().catch((e) => {
      console.error("Erreur lors du chargement initial pour la commune par défaut :", e);
    });

    initGeoUi().catch((e) => {
      console.error("Erreur lors de l'initialisation des sélecteurs de communes :", e);
    });

    await initialLoad;
  });
})();
</script>
